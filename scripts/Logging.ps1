<# Logging Functionality (Debugging)
 # ------------------------------
 # ==============================
 # ==============================
 # This class allows the ability for this program to log its activities performed within the environment.
 #  With this functionality available, it may help to trace how bugs are reproduced and why - within
 #  a different environment.  Furthermore, logs created within this program - is intended for debugging
 #  purposes only.  Logs that are generated by this application will be stored internally on the host's
 #  system.  Logs will not be submitted to another node within the network or Wide Area Network, only
 #  exception to this rule is if the individual user - manually - provides their logs to the public or
 #  to any medium outside from the localized environment hosted by the user's system.  This is a long
 #  clause to state that Telemetry is not being practiced here; if it were to change - this must be
 #  updated and user's choice must be allowed.
 #
 # If incase I forget to update the header (this comment block), add in Telemetry (yes, it is possible 
 #  in a degree in PowerShell), and also I forgot to provide user choice to opt-in as well as opt-out,
 #  please violently throw feathers towards my direction.  Just make sure you first clean the feathers
 #  before throwing them at me, please.
 #>




class Logging
{
    # Member Variables :: Properties
    # =================================================
    # =================================================


    #region Variables

    # Program Log Path
    # ---------------
    # The centralized location of where the program's logfiles will be located.
    Static [string] $ProgramLogPath = "$($GLOBAL:_PROGRAMDATA_LOGS_PATH_)\Program";


    # Program Log Filename
    # ---------------
    # The filename of the program's log file.
    Static [string] $ProgramLogFileName = "$($GLOBAL:_PROGRAMNAMESHORT_).log";

    #endregion



    # Member Functions :: Methods
    # =================================================
    # =================================================


    #region Private Functions


   <# Get Logging Lock Key
    # -------------------------------
    # Documentation:
    #  This function will return the current value of the logging lock key.  This lock
    #  will prevent information from being logged in a recursive manner.
    #
    # NOTE: This lock is only used internally within the program; this will be updated
    #        programmatically depending on certain circumstances.
    # -------------------------------
    # Output:
    #   [bool] Lock status
    #       $true = A function requested the logging lock to be enabled.
    #       $false = No function has the lock placed presently.
    # -------------------------------
    #>
    static Hidden [bool] __GetLoggingLockKey()
    {
        return $Global:_LOGGINGLOCKKEY_;
    } # __GetLoggingLockKey()




   <# Set Logging Lock Key
    # -------------------------------
    # Documentation:
    #  This function will allow the possibility to temporarily pause or resume the logging functionality.
    #   This lock will prevent information from being logged in a recursive manner, which if not set
    #     properly during runtime may result into a Stack Overflow (not talking about the website).
    #   - When true, a function 
    #   - When setting this to true, the logging functionality will be locked or disabled temporarily.
    #      If a function is requesting an event or action to be logged, the request will be ignored.  Do
    #      keep in mind that the logging functionality will still operate as intended, however no logs will
    #      written or appended too.  To undo this action, toggle the lock key to resume the logging feature.
    #   - When setting this to false, the logging functionality will resume its entire logging protocol.
    #      Thus, the logging information will be written to the log file as normal.
    # -------------------------------
    # Input:
    #  [bool] New Value
    #   $True = Logging functionality is temporarily paused; nothing is written to the filesystem.
    #   $False = Logging functionality is allowed to write; data and information is now written to the filesystem.
    # -------------------------------
    #>
    static Hidden [void] __SetLoggingLockKey([bool] $value)
    {
        $Global:_LOGGINGLOCKKEY_ = $value;
    } # __SetLoggingLockKey()




   <# Generate Timestamp
    # -------------------------------
    # Documentation:
    #  This function will generate a timestamp that can be used for the information that will be stored in the
    #   logfile.  The timestamp will help to provide a depiction of when an event or activity occurred within
    #   the program's runtime.
    # -------------------------------
    # Output:
    #  [string] Session Timestamp
    #   The generated timestamp which can be used the for information being written in a logfile.
    # -------------------------------
    #>
    Static Hidden [string] __GenerateTimestamp()
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string] $timestamp = $null;    # This will hold our full timestamp
        [string] $cacheTime = $null;    # This will hold the current time
        [string] $cacheDate = $null;    # This will hold the current date
        # ----------------------------------------


        # Get the current time
        $cacheTime = "$(Get-Date -UFormat "%H.%M.%S")";

        # Get the current date
        $cacheDate = "$(Get-Date -UFormat "%d-%b-%y")";

        # Now put it all together
        $timestamp = "$($cacheDate) $($cacheTime)";


        # Return the timestamp
        return "$($timestamp)";
    } # __GenerateTimestamp()




   <# Check Required Directories
    # -------------------------------
    # Documentation:
    #  This function will check to make sure that the logging directory, that will be used
    #   within this class, currently exists within the host system's filesystem.
    #
    # ----
    #
    #  Directories to be checked:
    #   - %LOCALAPPDATA%\<PROG_NAME>\Logs\Program
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #    $false = One or more directories does not exist.
    #    $true = Directories exist
    # -------------------------------
    #>
    Static Hidden [bool] __CheckRequiredDirectories()
    {
        # Declarations and Initializations
        # ----------------------------------------
        [bool] $controlLockKey  = $false;       # This will help to determine the lock status; wither
                                                #  the 'Logging Lock Key' is being controlled by any of
                                                #  the outside functions.
        [bool] $exitCode        = $false;       # Provides the status code if all of the required directories
                                                #  are present in the host's filesystem.
        # ----------------------------------------


        # Determine if the logging lock key had already been set by another function within the program
        if ([Logging]::__GetLoggingLockKey())
        {
            # Another function has already placed a logging lock, do not manipulate the main lock directly.
            $controlLockKey = $false;
        } # if : Logging lock key controlled outside

        # The logging lock is presently not locked; this function may control it.
        else
        {
            # This function may control the logging lock.
            $controlLockKey = $true;

            # Lock the Logging functionality; this is required to avoid recursive calls.
            [Logging]::__SetLoggingLockKey($true);
        } # else : Logging lock key is controlled by this function



        # Check the Program Log Directory
        if (([IOCommon]::CheckPathExists("$([Logging]::ProgramLogPath)", $true)) -eq $true)
        {
            # All of the required directories are present within the filesystem
            $exitCode = $true;
        } # If : Check Directories Exists

        else
        {
            # One or more of the required directories are missing from the filesystem.
            $exitCode = $false;
        } # Else : Directories does not exist


        # If this function is controlling the Logging Lock Key, unlock it now - before leaving this function.
        if($controlLockKey)
        {
            # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
            [Logging]::__SetLoggingLockKey($false);
        } # If : This function controls the logging lock key


        # Return the status to the calling function
        return $exitCode;
    } # __CheckRequiredDirectories()




   <# Create Directories
    # -------------------------------
    # Documentation:
    #  This function will create the necessary directories that will hold the log files
    #   that are generated from this class.  If the directories do not exist in the
    #   filesystem already, there is a chance that some operations might fail due to the
    #   inability to safely store the log files generated by the functions within this
    #   class.  If the directories do not already exist, this function will try to create
    #   them automatically - without interacting with the end-user.  If the directories
    #   already exist within the filesystem, then nothing will be performed.
    #
    # ----
    #
    #  Directories to be checked:
    #   - %LOCALAPPDATA%\<PROG_NAME>\Logs\Program
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #    $false = Failure creating the new directories.
    #    $true  = Successfully created the new directories
    #             OR
    #             Directories already existed, nothing to do.
    # -------------------------------
    #>
    Static Hidden [bool] __CreateDirectories()
    {
        # Declarations and Initializations
        # ----------------------------------------
        [bool] $controlLockKey  = $false;       # This will help to determine the lock status; wither
                                                #  the 'Logging Lock Key' is being controlled by any of
                                                #  the outside functions.
        # ----------------------------------------


        # Determine if the logging lock key had already been set by another function
        if ([Logging]::__GetLoggingLockKey())
        {
            # Another function has already placed a logging lock, do not manipulate the main lock.
            $controlLockKey = $false;
        } # if : Logging lock key controlled outside

        # The logging lock is presently not locked; this function may control it.
        else
        {
            # This function may control the logging lock.
            $controlLockKey = $true;

            # Lock the Logging functionality; this is required to avoid recursive calls.
            [Logging]::__SetLoggingLockKey($true);
        } # else : Logging lock key is controlled by this function



        # First, check if the directories already exist?
        if(([Logging]::__CheckRequiredDirectories())-eq $true)
        {
            # If this function is controlling the Logging Lock Key, unlock it now - before leaving.
            if($controlLockKey)
            {
                # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
                [Logging]::__SetLoggingLockKey($false);
            } # If : This function controls the logging lock key

            # The directories exist, no action is required.
            return $true;
        } # IF : Check if Directories Exists


        # ----


        # Because the logging directory was not detected, we must create the directory before we can use it
        #  within the program.

        # Program Log Directory
        if(([IOCommon]::CheckPathExists("$([Logging]::ProgramLogPath)", $true)) -eq $false)
        {
            # Program's Log Directory does not exist, try to create it.
            if (([IOCommon]::MakeDirectory("$([Logging]::ProgramLogPath)")) -eq $false)
            {
                # If this function is controlling the Logging Lock Key, unlock it now - before leaving.
                if($controlLockKey)
                {
                    # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
                    #  -- NOTE: If other functions already have it set - do not touch it!
                    [Logging]::__SetLoggingLockKey($false);
                } # If : This function controls the logging lock key

                # Failure occurred.
                return $false;
            } # If : Failed to Create Program Log Directory
        } # Program Log Directory


        # ----


        # Fail-safe; final assurance that the program's log directory had been created successfully.
        if(([Logging]::__CheckRequiredDirectories())-eq $true)
        {
            # If this function is controlling the Logging Lock Key, unlock it now - before leaving.
            if($controlLockKey)
            {
                # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
                [Logging]::__SetLoggingLockKey($false);
            } # If : This function controls the logging lock key

            # The directories exist
            return $true;
        } # IF : Check if Directories Exists


        # If this function is controlling the Logging Lock Key, unlock it now - before leaving.
        if($controlLockKey)
        {
            # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
            [Logging]::__SetLoggingLockKey($false);
        } # If : This function controls the logging lock key


        # A failure occurred during the Final Assurance check; the program's log directory could not be created.
        return $false;
    } # __CreateDirectories()




   <# Write to Logfile [Write File]
    # -------------------------------
    # Documentation:
    #  This function will take the provided data (as a string) and write the information into a specific
    #   logfile.  If incase the logfile does not exist, this function will try to create it on the host's
    #   filesystem.
    # -------------------------------
    # Input:
    #  [string] Message
    #   The message that will be written to the logfile.
    # -------------------------------
    # Output:
    #  [bool] Status Code
    #    $false = Operation failed
    #             OR
    #             Logging Is locked; cannot write to secondary storage due to the Logging Lock Key value.
    #    $true  = Operation was successful
    # -------------------------------
    #>
    Static Hidden [bool] __WriteLogFile([string] $message)
    {
        # Declarations and Initializations
        # ----------------------------------------
        [bool] $controlLockKey  = $false;       # This will help to determine the lock status; wither
                                                #  the 'Logging Lock Key' is being controlled by any of
                                                #  the outside functions.
        [bool] $exitCode        = $false;       # Provides the exit code of the operation performed
                                                #  within the function.
        # ----------------------------------------


        # Determine if the logging lock key had already been set by another function
        if ([Logging]::__GetLoggingLockKey())
        {
            # Another function had already placed a logging lock, we can NOT proceed in this function.
            #  Return immediately.
            return $false;
        } # if : Logging lock key controlled outside

        # The logging lock is presently not locked; this function may control it.
        else
        {
            # This function may control the logging lock.
            $controlLockKey = $true;

            # Lock the Logging functionality; this is required to avoid recursive calls.
            [Logging]::__SetLoggingLockKey($true);
        } # else : Logging lock key is controlled by this function



        # Make sure that the required directories exist for logging, if not - try to create it.
        if ([Logging]::__CreateDirectories() -eq $false)
        {
            # Because the logging directory could not be created, there is no point in
            #  trying to write information to a log file - when the directory does not exist.
            Write-Output "ERR! Program Log Directory failed to be created!";

            # Provide an error code
            $exitCode = $false;
        } # If : Program Log Dir. does not exist.


        # Make sure that there is something to actually write, if there is no message - then
        #  there is no point in trying to write to the logfile.
        elseif ("$($message)" -eq "$($null)")
        {
            # Because the message is empty, there is really no point in written to the logfile.
            Write-Output "ERR! Message can not be recorded as it is null!";

            # Provide an error code
            $exitCode = $false;
        } # Else-If : Message is empty


        # Write the readable data to the logfile.
        elseif (([IOCommon]::WriteToFile("$([Logging]::GetLogFilePath())", "$($message)")) -eq $false)
        {
            # The message could not be written to the logfile.  Provide an exit code of false to signify failure.
            $exitCode = $false;
        } # Else-If : Operation Failed

        # Operation was successful
        else
        {
            # Because the operation was completed, set the exit code as successful.
            $exitCode = $true;
        } # Else : Successful operation


        # If this function is controlling the Logging Lock Key, unlock it now - before leaving.
        if($controlLockKey)
        {
            # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
            [Logging]::__SetLoggingLockKey($false);
        } # If : This function controls the logging lock key


        # Return the status to the calling function
        return $exitCode;
    } # __WriteLogFile()




   <# Format Log Message
    # -------------------------------
    # Documentation:
    #  This function will format the information that is provided to this method.
    #   Within this function, once the information has been formatted in a unified
    #   form, the information will be passed to another function which will write
    #   the data to the logfile.
    #
    #  In order to write to the program's logfile, it is recommended to pass to this
    #   function.
    # -------------------------------
    # Input:
    #  [LogMessageLevel] Message Level
    #    The message level severity of the information provided.
    #  [String] Initial Message
    #    The message that will be recorded in the logfile.
    #  [String] Additional Information (Optional)
    #    Additional information that relates to the initial message.
    # -------------------------------
    # Output:
    #  [bool] Status Code
    #    $false = Operation failed
    #    $true  = Operation was successful 
    # -------------------------------
    #>
    static Hidden [bool] __FormatLogMessage([LogMessageLevel] $msgLevel, `      # Message level
                                            [String] $msg, `                    # Main message to be logged
                                            [String] $additionalMsg)            # (OPTIONAL) Additional information relating to the main message.
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string] $currentTimeStamp = $null;     # The current time of when the message had been captured.
        [string] $message = $null;              # The main message that will be logged.
        [string] $messageLevel = $null;         # The level of severity regarding the message.
        [string] $messageAdditional = $null;    # Additional information regarding the initial message.
                                                #  Such information may contain brief messages about the error.
        [string] $borderLine = $null;           # This will provide a horizontal line that will help to separate
                                                #  the header and the content relating to the message.
        [string] $finalMessage = $null;         # The final message that will be written to the logfile.
        # ----------------------------------------


        # Provide a horizontal border to separate the header and the initial message.
        $borderLine = "- - - - - - - - - - - - - - - - - - - - -";



        # - - - - - - -



        # Evaluate the information passed to this function.  If any of the values are not provided,
        #  then we will provide a default or error message instead - - we must avoid blank entries
        #  in the logfile.



        # First: Message Data
        # ---------------------------
        # - - - - - - - - - - - - - -
        # Make sure that the initial message exists; if the initial message is blank (or null), then provide
        #  some default message to indicate that something is wrong - but we managed to log the error regardless.

        # There was no initial message provided
        if ("$($msg)" -eq "$($null)")
        {
            # Provide an default error message; helps to indicate that something went horribly wrong.
            $message = "<<UNKNOWN OR BLANK MESSAGE>>";
        } # If: Unknown or Blank Message

        # Obtain the initial message
        else
        {
            # Capture the message
            $message = $msg;
        } # Else: Message Data was Provided



        # - - - - - - - - - - - - - -



        # Second: Message Level
        # ---------------------------
        # - - - - - - - - - - - - - -
        # Try to fetch the message level; the severity or what kind of message that is provided with the data.

        # The message level was not provided or is not obtainable.
        if ("$($msgLevel)" -eq "$($null)")
        {
            # The message level is unknown
            $messageLevel = "UNKNOWN";
        } # If: Unknown Message Level

        # The message level was provided
        else
        {
            # Capture the message level
            $messageLevel = $msgLevel;
        } # Else: Message Level was Provided



        # - - - - - - - - - - - - - -



        # Third: Additional Information
        # ---------------------------
        # - - - - - - - - - - - - - -
        # Any additional information provided, optional field.  This can be null (or merely empty).

        # No additional information provided
        if ("$($additionalMsg)" -eq "$($null)")
        {
            # No additional information was provided
            $messageAdditional = "$($null)";
        } # If: No Additional Information was Provided

        # Additional information was provided
        else
        {
            # There exists some additional information, format it in a way that it works in the final
            #  message form.
            $messageAdditional = "Additional Information:`r`n`t$($additionalMsg)";
        } # Else: Additional Information was Provided



        # - - - - - - - - - - - - - -



        # Fourth: Timestamp
        # ---------------------------
        # - - - - - - - - - - - - - -
        # Generate the timestamp for when the message is about to be logged.

        # Fetch the timestamp and cache it.
        $currentTimeStamp = [Logging]::__GenerateTimestamp();



        # = = = = = = = = = = = = = =
        # - - - - - - - - - - - - - -
        # = = = = = = = = = = = = = =



        # Fifth: Final Form
        # ---------------------------
        # - - - - - - - - - - - - - -
        # Put the message in its final form, this message will be written to the logfile.
        $finalMessage = ("{$($currentTimeStamp)}-($($messageLevel))`r`n" + `        # Header of the log entry
                        "$($borderLine)`r`n" + `                                    # - - BORDER - -
                        "$($message)`r`n" + `                                       # Message Content
                        "`r`n" + `                                                  # - - NEW LING SPACE - -
                        "$($messageAdditional)`r`n" + `                             # Additional Information (if any)
                        "`r`n`r`n");                                                # Padding for the next log entry.


        # - - - -


        # Write the message to the logfile.
        return [Logging]::__WriteLogFile("$($finalMessage)");
    } # __FormatLogMessage()

    #endregion



    #region Public Functions


   <# Get Exception Information (Short)
    # -------------------------------
    # Documentation:
    #  This function provides some insight regarding an exception that occurred, within PowerShell's
    #   engine, during an operation at runtime.  This is useful to provide the information to the user
    #   at run-time.
    # -------------------------------
    # Inputs:
    #  [Exception] Error Details
    #   The exception object that contains further information regarding the exception that was thrown.
    # -------------------------------
    # Output:
    #  [string] Exception Information
    #   Some insight information regarding the exception that was thrown.
    #
    #   ERROR VALUES
    #    null = No exception object provided, or information was null.
    # -------------------------------
    #>
    static [string] GetExceptionInfoShort ([Exception] $errDetail)
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string] $information = $null;          # This variable will contain information regarding the
                                                #  exception passed to this function.
        # ----------------------------------------


        # Check to make sure the exception passed to this function is not null.
        if ($null -eq $errDetail)
        {
            # Because the Exception object is null, we can not extract anything useful from it.
            return $null;
        } # If : Exception is null

        # Generate the exception information that will be returned to the calling function.
        $information = ("Reached an exception: $($errDetail.GetType())`r`n" + `
                        "More information is provided in the program's logfile.`r`n" + `
                        "Logfile can be found in:`r`n`t$([Logging]::GetLogFilePath())");


        # Return the short details of the error
        return $information;
    } # GetExceptionInfoShort()




   <# Get Exception Information
    # -------------------------------
    # Documentation:
    #  This function provides detailed information regarding an exception that had occurred during
    #   the program's runtime.  This is useful to provide the information within the program's logfile.
    # -------------------------------
    # Inputs:
    #  [Exception] Error Details
    #   The exception object that contains further information regarding the exception that was thrown.
    # -------------------------------
    # Output:
    #  [string] Exception Information
    #   Detailed information regarding the exception as a multiple line string.
    #
    #   ERROR VALUES
    #    null = No exception object provided, or information was null.
    # -------------------------------
    #>
    static [string] GetExceptionInfo ([Exception] $errDetail)
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string] $information = $null;          # This variable will contain information regarding the
                                                #  exception passed to this function.
        # ----------------------------------------


        # Check to make sure the exception passed to this function is not null
        if ($null -eq $errDetail)
        {
            # Because the Exception object is null, we can not extract anything from it.
            return $null;
        } # If : Exception is null

        # Generate the exception information that will be returned to the calling function.
        $information = ("`tException Reached: $($errDetail.GetType())`r`n" + `
                        "`tException Message: $($errDetail.Message)`r`n" + `
                        "`tException Source: $($errDetail.Source)`r`n" + `
                        "`tException Target Site: $($errDetail.TargetSite)`r`n" + `
                        "`tException Stack Trace:`r`n" + `
                        "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~`r`n" + `
                        "$($errDetail.StackTrace)`r`n" + `
                        "~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~");


        # Return the details of the error
        return $information;
    } # GetExceptionInfo()




   <# Get Program Logfile
    # -------------------------------
    # Documentation:
    #  This function will return the program's logfile absolute path location.
    # -------------------------------
    # Output:
    #   [string] Logfile path
    #       The absolute path of the program's logfile.
    # -------------------------------
    #>
    static [string] GetLogFilePath()
    {
        return "$([Logging]::ProgramLogPath)\$([Logging]::ProgramLogFileName)";
    } # GetLogFilePath()




   <# Allow Logging
    # -------------------------------
    # Documentation:
    #  This function will provide the current status if the logging functionality, which
    #   could be either enabled or disabled.
    # -------------------------------
    # Output:
    #  [bool] Logging State
    #   $false = Logging is currently disabled
    #   $true = Logging is currently enabled
    # -------------------------------
    #>
    static [bool] DebugLoggingState()
    {
        return $Global:_DEBUGLOGGING_;
    } # DebugLoggingState()




   <# Thrash Logs and Reports
    # -------------------------------
    # Documentation:
    #  This function will expunge the log files that are currently present within the logging
    #   directory.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = One or more operations failed.
    #   $true = Successfully expunged the files.
    #           OR
    #           Logging directory was not found.
    # -------------------------------
    #>
    Static [bool] ThrashLogs()
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string[]] $extLogs     = @('*.log');   # Array of log extensions
        [bool] $exitCode        = $false;       # Provides the exit code of the operation performed
                                                #  within the function.
        [bool] $controlLockKey  = $false;       # This will help to determine the lock status; wither
                                                #  the 'Logging Lock Key' is being controlled by any of
                                                #  the outside functions.
        # ----------------------------------------


        # Determine if the logging lock key had already been set by another function.
        if ([Logging]::__GetLoggingLockKey())
        {
            # Another function had already placed a logging lock, do not manipulate the main lock.
            $controlLockKey = $false;
        } # if : Logging lock key controlled outside

        # The logging lock is presently not locked; this function may control it.
        else
        {
            # This function may control the logging lock.
            $controlLockKey = $true;

            # Lock the Logging functionality; this is required to avoid recursive calls.
            [Logging]::__SetLoggingLockKey($true);
        } # else : Logging lock key is controlled by this function


        # First, make sure that the log directory exists.
        #  If the directory is not available, then there is nothing that can be done.
        if (([Logging]::__CheckRequiredDirectories()) -eq $false)
        {
            # This is not really an error, however the logging directory simply does not
            #  exist -- nothing can be done.
            $exitCode = $false;
        } # IF : Required Directory Exist


        # Because the logging directory exist, lets try to thrash the log files.
        elseif (([IOCommon]::DeleteFile("$([Logging]::ProgramLogPath)", $extLogs)) -eq $false)
        {
            # Failure to remove the requested files
            $exitCode = $false;
        } # Else-If : Failure to delete Program Logs

        # The deletion operation was successful
        else
        {
            # If we made it here, then everything went okay!
            $exitCode = $true;
        } # Else : Successfully deleted the files


        # If this function is controlling the Logging Lock Key, unlock it now - before leaving.
        if($controlLockKey)
        {
            # Because this function has the Logging Lock Key controlled, unlock it now to avoid conflicts.
            [Logging]::__SetLoggingLockKey($false);
        } # If : This function controls the logging lock key


        return $exitCode;
    } # ThrashLogs()




   <# Display Message
    # -------------------------------
    # Documentation:
    #  This function will provide information to be displayed to the end-user while also simultaneously written
    #   onto the program's logfile.  This functionality will help to capture all of the output messages that are
    #   to be displayed onto the user's screen - while also be captured into the program's logfile for debugging
    #   purposes.
    #
    # NOTE:
    #  The formatting and specifications of the message will be evaluated in the inner-specific functions
    #   that are called within this method.
    # -------------------------------
    # Input:
    #  [string] Message
    #   The message that is to be presented on the screen and written in the logfile.
    #  [LogMessageLevel] Message Level
    #   The level of the message that is to be presented or formatted.
    # -------------------------------
    #>
    static [void] DisplayMessage([string] $msg,                     # Message to provide to both Display and Logfile
                                [LogMessageLevel] $msgLevel)        # Message's severity level
    {
        # Display the message to the end-user's screen.
        [IOCommon]::WriteToBuffer("$($msg)", "$($msgLevel)");

        # Log the message to the logfile.
        [Logging]::__FormatLogMessage("$($msgLevel)", "$($msg)", "$($null)") | Out-Null;
    } # DisplayMessage()




   <# Display Message (Short-Hand\Standard MSGs)
    # -------------------------------
    # Documentation:
    #  This overload function is merely an expeditious way of reaching the DisplayMessage(arg0, arg1)
    #   method.  However, this function will always assume that the Message Severity is 'Standard'.
    #   Because PowerShell does not allow default arguments to be set, at least at the time of writing
    #   this statement, this function will allow overloading of the arguments.
    #
    # NOTE:
    #  Any messages coming through this function will be treated as a Standard Message!
    # -------------------------------
    # Input:
    #  [string] Message
    #   The message that is to be presented on the screen and written to the logfile.
    # -------------------------------
    #>
    static [void] DisplayMessage([string] $msg)
    {
        # Access the DisplayMessage(arg0, arg1) with MSG Level set to standard severity.
        [Logging]::DisplayMessage("$($msg)", "Standard");
    } # DisplayMessage()




   <# Get User Input
    # -------------------------------
    # Documentation:
    #  This function will allow the ability to capture the user's input (STDIN) and log the
    #   same input onto the program's logfile.  This will help with debugging purposes.
    # -------------------------------
    # Output:
    #  [string] User's Input Request
    #    Returns the user's input.
    # -------------------------------
    #>
    static [string] GetUserInput()
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string] $userInput = $null;        # This will hold the user's feedback
        # ----------------------------------------


        # Fetch user input, normally.
        $userInput = [IOCommon]::FetchUserInput();

        # Provide the user's input into the logfile and record it.
        [Logging]::__FormatLogMessage(7, "$($userInput)", "$($null)") | Out-Null;

        # Return the user's request
        return "$($userInput)";
    } # GetUserInput()




   <# Log Program Activity
    # -------------------------------
    # Documentation:
    #  This function will allow the ability for the program to record internal activities.
    #   Information provided here may or may not be visible to the end-user via the terminal.
    #   screen, but the data can be useful for debugging and understanding what actions are
    #   occurring under the hood of the application during run-time.
    # -------------------------------
    # Input:
    #  [string] Message
    #   The initial message that will be recorded into the logfile.
    #  [string] Additional Information
    #   Additional information relating to the initial message.
    #  [LogMessageLevel] Message Level
    #   The severity or level of the message that is about to be recorded in the logfile.
    # -------------------------------
    #>
    static [void] LogProgramActivity([string] $message, `                   # The message to be recorded
                                    [string] $additionalInformation, `      # Additional information to be recorded
                                    [LogMessageLevel] $messageLevel)        # Severity of the message
    {
        # Because we have the information already provided for us, we will merely pass the
        #  data to the appropriate functions to properly record it in the logfile.
        [Logging]::__FormatLogMessage($messageLevel, `
                                    "$($message)", `
                                    "$($additionalInformation)") | Out-Null;
    } # LogProgramActivity()




   <# Write to Logfile
    # -------------------------------
    # Documentation:
    #  This function will allow the ability to write information to a specific logfile upon
    #   request, though only if logging functionality is enabled or if the logging functionality
    #   is available at the time upon request.
    # -------------------------------
    # Input:
    #  [string] File Path
    #   The absolute path of the logfile that is about to be generated.
    #  [string] (REFERENCE) Message
    #   The information that is going to be written to the logfile.
    #   NOTE: The message can be as long as the CLR (which is about 2.5GB)
    # -------------------------------
    #>
    static [void] WriteToLogFile([string] $filePath,        # The absolute path of the logfile
                                [ref] $msg)                 # The message to be written
    {
        # If the logging functionality is enabled, write the information as requested.
        if ([Logging]::DebugLoggingState())
        {
            # Logging is available presently, write the file as requested.
            [IOCommon]::WriteToFile("$($filePath)", "$($msg.Value.ToString())") | Out-Null;
        } # If : Logging is enabled & available
    } # WriteToLogFile()

    #endregion
} # Logging




<# Message Level [ENUM]
 # -------------------------------
 # The level of the message that is about to be presented to the screen or how the information
 #  is to be logged for future references.
 # -------------------------------
 #>
enum LogMessageLevel
{
    Standard        = 0;    # Regular messages
    Attention       = 1;    # Confirmation messages
    Information     = 2;    # Informational messages
    Warning         = 3;    # Warning messages
    Error           = 4;    # Error messages
    Fatal           = 5;    # Program death messages
    Verbose         = 6;    # Debug or detailed messages.
    UserInput       = 7;    # User Feedback\Input (STDIN\Keyboard)
} # IOCommonBufferMessageLevel