<# Builder
 # ------------------------------
 # ==============================
 # ==============================
 # This class is the heart of the program - in which it allows the
 #  desired project to be compiled into a single archive data file.
 #  The builder will perform various steps to assure that the project
 #  is up to date with the remote repository, assure that all of the
 #  dependencies are ready for use, perform the compiling operation,
 #  verify the integrity of the newly generated archive datafile,
 #  and create any useful documentation as requested.  The user has
 #  full flexibility as to how the Builder operates and with what
 #  capabilities are usable.
 #>



class Builder
{
   <# Build
    # -------------------------------
    # Documentation:
    #  This function is essentially our main driver into creating a
    #   ZDoom based archive datafile generated by using the project's
    #   source files.  Because this function is our main driver into
    #   achieving this goal, we have to assure that the process is
    #   well organized and is keeping the operation - easy to manage.
    #   By doing this, we will want to approach this in a sequential
    #   manner while also checking our work consistently.  Meaning,
    #   in order to compile the project's source files into one single
    #   archive file, we may need to update the source via a Source
    #   Control tool - then we may proceed with compacting the data.
    #   This is only a brief example out of many possible cases now
    #   and as well in the future when and if the functionality were
    #   to expand.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = The Project Build had reached an error.
    #   $true = The Project Build had successfully been created.
    # -------------------------------
    #>
    static [bool] Build()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Archive datafile's final destination path
        [string] $compiledBuildPath = $null;

        # The file name for the archive datafile.
        [string] $fileName = $null;
        # ----------------------------------------


        # Clear the terminal of all previous text; keep the space clean so that
        #  it is easy for the user to read and follow along.
        [CommonIO]::ClearBuffer();


        # Draw Program Information Header
        [CommonCUI]::DrawProgramTitleHeader();


        # Show the user that they are at the Main Menu
        [CommonCUI]::DrawSectionHeader("Compiling the $([ProjectInformation]::projectName) [$([ProjectInformation]::codeName)] Project");


        # Display the instructions
        [CommonCUI]::CompileInstructions();





        #           Prerequisite Check
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Make sure that we have all of the resources that we are going to
        #  need in order to successfully compile this project.
        if (![Builder]::PrerequisiteCheck())
        {
            # Because we are lacking a required resource, we cannot proceed with
            #  this process.
            return $false;
        } # if : Evaluate Prerequisite Check


        # Because we have all of the resources that we need - in order to compile
        #  this project, we can proceed to the next step!





        #        Generate Output Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *
        # Determine and generate the output directory in which this compiled
        #  build will be stored.

        $compiledBuildPath = "$([Builder]::GenerateOutputPath())";





        #           Update Source (Git)
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to update the user's copy of the project files.
        if (![Builder]::UpdateProject())
        {
            # Because there was an error while attempting to update the user's
            #  local copy of the project files, we cannot proceed.
            return $false;
        } # if : Update Local Project Files





        #            Generate Filename
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # We will need to know the file name that will identify archive datafile,
        #  as well as the file extension that will help to classify the archive
        #  datafile's data structure.
        $fileName = [Builder]::GenerateArchiveFileName();





        #             Compile Project
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to compact the project files into an archive datafile.
        if (![Builder]::CompileProject($fileName, [ref]$compiledBuildPath))
        {
            # Because there was an error while compiling the project's source
            #  files, we will have to abort at this point.
            return $false;
        } # if : Compile Project





        #               Test Build
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to test the archive data file to assure that it is not damaged.
        if (![Builder]::TestCompiledBuild($compiledBuildPath))
        {
            # Because the archive datafile is damaged or corrupted, we will have
            #  to abort the operation as we reached an error.
            return $false;
        } # if : Test Compiled Build





        # Show that the compiling operation was successful.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Operation had been completed!");


        # Operation was successful!
        return $true;
    } # Build()




   <# Prerequisite Check
    # -------------------------------
    # Documentation:
    #  This function performs a validation check to assure that all
    #   of the required resources are available for the compiling
    #   process.  If incase we found one or more resources - that
    #   is imperative for the entire operation to work correctly -
    #   then we may ultimately abruptly abort the entire compile
    #   operation.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = One or more resources were missing but required.
    #   $true = All of the resources were accounted for and ready.
    # -------------------------------
    #>
    hidden static [bool] PrerequisiteCheck()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's Git Control object; this contains the user's
        #  preferences as to how Git will be used within this application.
        [GitControl] $gitControl = [GitControl]::GetInstance();

        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();

        # We will use this variable to cache the detection status of a particular item that we want
        #  to check.  Instead of having to recall the exact same checking function over and over again,
        #  we will use this variable to merely cache the value as we step through each process within
        #  the checking procedure.
        [bool] $boolCacheValue = $false;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # Show that the Prerequisite functionality is presently active
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Prerequisite Check");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Performing a Prerequisite Check. . .");



        #              Project Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Project Path
        $boolCacheValue = [CommonIO]::CheckPathExists("$($userPreferences.GetProjectPath())", $true);

        # Can we find the project's source files?
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the project's source files; unable to continue.

            # Show that the Project's source files could not be found.
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find $([ProjectInformation]::projectName) source files!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the program settings!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I am unable to find the $([ProjectInformation]::projectName) source files!`r`n" + `
                                            "Please reconfigure the path for the $([ProjectInformation]::projectName) project!`r`n" + `
                                            "`t- $([ProjectInformation]::projectName) Project Path is presently: $($userPreferences.GetProjectPath())`r`n" + `
                                            "`t- Path Exists Detection Status: $([string]$boolCacheValue)");

            # Generate the initial message
            $logMessage = "Unable to find the $([ProjectInformation]::projectName) project's source files!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please reconfigure the location of the $([ProjectInformation]::projectName) Project's Source.`r`n" + `
                                "`tProject Source Location is: $($userPreferences.GetProjectPath())`r`n" + `
                                "`tProject Source Path Exists: $([string]$boolCacheValue)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                        "$($logAdditionalMSG)", `   # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the project's source files, we have to abort the operation.
            return $false;
        } # if : Check Project source files exists



        # Successfully found project files
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the $([ProjectInformation]::projectName) source files!");




        #              Output Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Output Path
        $boolCacheValue = [CommonIO]::CheckPathExists("$($userPreferences.GetProjectBuildsPath())", $true);

        # Can we find the output path?
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the output path directory; unable to continue.

            # Show that the Output Directory could not be found.
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the Output Directory!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the Program's Generalized Settings!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I cannot find the folder to store any new compiled builds!`r`n" + `
                                            "Please reconfigure the Output Path in the program's general settings!`r`n" + `
                                            "`t- Output Path is presently: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                            "`t- Path Exists Detection Status: $([string]$boolCacheValue)");

            # Generate the initial message
            $logMessage = "Unable to find the Output Directory!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please reconfigure the location of the Output Directory.`r`n" + `
                                "`tOutput Directory Location is: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                "`tOutput Directory Path Found: $([string]$boolCacheValue)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                        "$($logAdditionalMSG)", `   # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the output directory, we have no place to place the
            #  compiled build.  We cannot continue this operation.
            return $false;
        } # if : Check Output Path exists



        # Successfully found output directory
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the Output Directory!");




        #            Compression Tool
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Determine if the chosen compression tool is available for us to utilize.
        switch ($userPreferences.GetCompressionTool())
        {
            # dotNET Archive Zip
            ([UserPreferencesCompressTool]::InternalZip)
            {
                # Check the current status of the Archive ZIP Module
                $boolCacheValue = [CommonFunctions]::IsAvailableZip();

                # Make sure that the dotNET Archive Zip is available
                if ($boolCacheValue -eq $false)
                {
                    # Unable to find the dotNET Archive Zip

                    # Show that this program cannot detect the dotNET Core Archive ZIP functionality.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find native support with Default ZIP functionality");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you are using the latest version of PowerShell Core!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("I am unable to find support for ZIP in this version of PowerShell!`r`n" + `
                                                    "Please make sure that you are using the latest version of PowerShell Core!`r`n" + `
                                                    "`t- You are currently using PowerShell Core Version: $([SystemInformation]::PowerShellVersion())`r`n" + `
                                                    "`t- ZIP Archive Module Detection Status: $([string]$boolCacheValue)`r`n" + `
                                                    "`t- You may check out any new releases of the PowerShell Core at GitHub!`r`n" + `
                                                    "`t`thttps://github.com/PowerShell/PowerShell/releases");

                    # Generate the initial message
                    $logMessage = "Unable to find the dotNET Archive Zip Module!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Please assure that you are currently using the latest version of PowerShell Core!`r`n" + `
                                        "`tArchive ZIP Module Detection reported: $([string]$boolCacheValue)`r`n" + `
                                        "`tPowerShell Version: $([SystemInformation]::PowerShellVersion())`r`n" + `
                                        "`tOperating System: $([String][SystemInformation]::OperatingSystem())`r`n" + `
                                        "`tCheck for new versions of PowerShell Core at the provided official website:`r`n" + `
                                        "`t`thttps://github.com/PowerShell/PowerShell/releases");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                                "$($logAdditionalMSG)", `   # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                    [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *


                    # Because we cannot find the default internal Archive Module within PowerShell, we
                    #  cannot proceed forward with the compiling phase.
                    return $false;
                } # If : Found Default Zip


                # Successfully found native support with the Archive ZIP module
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found native support with dotNET Core Archive ZIP!");


                # Finished
                break;
            } # dotNET Archive Zip


            # 7Zip
            ([UserPreferencesCompressTool]::SevenZip)
            {
                # Check the current status of the 7Zip application
                $boolCacheValue = [CommonFunctions]::IsAvailable7Zip();

                # Make sure that the 7Zip is available
                if ($boolCacheValue -eq $false)
                {
                    # Unable to find the 7Zip application

                    # Show that this program cannot find the 7Zip software installed on this system or the desired location.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the 7Zip application installed!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you have 7Zip installed and that this program can find it as well.");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("I am unable to find the 7Zip software on your computer!`r`n" + `
                                                    "Please assure that 7Zip had been properly installed on your computer!`r`n" + `
                                                    "`t- 7Zip Detection Status: $([string]$boolCacheValue)`r`n" + `
                                                    "`t- You may download the latest version of 7Zip at the official website!`r`n" + `
                                                    "`t`thttps://www.7-zip.org/download.html");

                    # Generate the initial message
                    $logMessage = "Unable to find the 7Zip Application!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Please assure that you currently have 7Zip installed and that $($Global:_PROGRAMNAME_) can detect it's installation path!`r`n" + `
                                        "`tFound 7Zip: $([String]$boolCacheValue)`r`n" + `
                                        "`t7Zip Path: $($sevenZip.GetExecutablePath())`r`n" + `
                                        "`tInstall the latest version of 7Zip at the official website:`r`n" + `
                                        "`t`thttps://www.7-zip.org/download.html");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                                "$($logAdditionalMSG)", `   # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *


                    # Because the user specified that we must use 7Zip in order to compile the builds,
                    #  then we must abort the operation as we are unable to find the software.
                    return $false;
                } # If : Found 7Zip


                # Successfully found 7Zip
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the 7Zip Application!");


                # Finished
                break;
            } # 7Zip


            # Unknown or Unsupported (Error Case)
            default
            {
                # Unknown or Unsupported compression tool!

                # Show that the preferred compression tool is not valid.
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Preferred Compression Tool is not supported or I don't know what it is!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the Compression Tool within the Program Generalized Settings!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("Please choose a valid Compression Tool within the Program's Generalized settings!`r`n" + `
                                                "The current compression tool that you had requested is either no longer supported or unknown.`r`n" + `
                                                "`t- Current Compression Tool ID is: $([uint]$userPreferences.GetCompressionTool())");

                # Generate the initial message
                $logMessage = "Requested compression software is either unsupported or unknown!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Please reconfigure your preferred Compression Tool within the Program's Generalized Settings!`r`n" + `
                                    "`tCompression Tool ID: $([uint]$userPreferences.GetCompressionTool())");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                            "$($logAdditionalMSG)", `   # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # * * * * * * * * * * * * * * * * * * *


                # Because this compression tool is not support or simply unknown, have to abruptly
                #  stop.
                return $false;
            } # Unknown or Unsupported
        } # Switch : Determine Specified Compression Tool




        #           Git Functionality
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Determine if the user wanted us to use Git Features
        if ($userPreferences.GetUseGitFeatures())
        {
            # Check the current status of the Git application
            $boolCacheValue = [CommonFunctions]::IsAvailableGit();

            # Assure that we are able to find the Git Application
            if ($boolCacheValue -eq $false)
            {
                # Unable to find the Git application.

                # Show that the preferred compression tool is not valid.
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the Git SCM Version Control Application!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you have Git installed and that this program can find it as well.");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("I am unable to find the Git Version Control software on your computer!`r`n" + `
                                                "Please assure that Git Version Control had been properly installed on your computer!`r`n" + `
                                                "`t- Git Detection Status: $([string]$boolCacheValue)`r`n" + `
                                                "`t- You may download the latest version of Git at the official website!`r`n" + `
                                                "`t`thttps://git-scm.com/");

                # Generate the initial message
                $logMessage = "Unable to find the Git Application!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Please assure that you currently have Git installed and that $($Global:_PROGRAMNAME_) can detect it's installation path!`r`n" + `
                                    "`tFound Git: $([String]$boolCacheValue)`r`n" + `
                                    "`tGit Path: $($gitControl.GetExecutablePath())`r`n" + `
                                    "`tInstall the latest version of GIT at the official website:`r`n" + `
                                    "`t`thttps://git-scm.com/");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                            "$($logAdditionalMSG)", `   # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # * * * * * * * * * * * * * * * * * * *


                # Because the user had requested that we utilize the Git software yet we are unable
                #  to find it, we may not continue with the compiling operation.
                return $false;
            } # if : Check if Git Exists



        # Successfully found Git SCM!
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the Git Application!");
        } # if : Git Features Requested




        #                  DONE!
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # If we made it this far, that means that we have everything we need to compile this project!


        # Show that the Perquisite Check had passed!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully found all the required resources!");




        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = ("The Prerequisite Check had determined that we have all of the required" + `
                        "resources necessary to compile the $([ProjectInformation]::projectName) project!");

        # Generate any additional information that might be useful
        $logAdditionalMSG = "Prerequisite Check had successfully passed!";

        # Pass the information to the logging system
        [Logging]::LogProgramActivity("$($logMessage)", `           # Initial message
                                    "$($logAdditionalMSG)", `       # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # If we made it to this point, then we have all of the resources
        #  that we need to compile this project!
        return $true;
    } # PrerequisiteCheck()





   <# Git - Update Project
    # -------------------------------
    # Documentation:
    #  This function will update the project's source files by
    #   updating the local repository, which in turn - updates
    #   the local working copy files at the same time.  In which
    #   assures that the user has the latest version of the
    #   project files within the selected branch.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to update the project source files
    #   $true = Successfully updated the project source files
    # -------------------------------
    #>
    hidden static [bool] UpdateProject()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's Git Control object; this contains the user's
        #  preferences as to how Git will be used within this application.
        [GitControl] $gitControl = [GitControl]::GetInstance();

        # We will use this to hold the local repository's last branch update Commit ID.
        [string] $projectCommitIDNew = $NULL;           # Updated Local Repository Commit ID
        [string] $projectCommitIDOld = $NULL;           # Before the Update Commit ID


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # First we will want to make sure that the user wanted us to update the project's source files
        if (($userPreferences.GetUseGitFeatures() -and $gitControl.GetUpdateSource()) -eq $false)
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to update the $([ProjectInformation]::projectName) local repository!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("User's Preferences for using Git Features: $($userPreferences.GetUseGitFeatures())`r`n" + `
                                "Git's Settings for Updating Project Source: $($gitControl.GetUpdateSource())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity("$($logMessage)", `           # Initial message
                                        "$($logAdditionalMSG)", `       # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because the user had requested that this step be skipped, then we will
            #  provide a successful signal.  Ideally, there was no error here, other
            #  than following the user's request.
            return $true;
        } # If : Do not update project source files




        # Show that we are about to update the project source files
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Update $([ProjectInformation]::projectName)");




        # If we made it this far, then we can try to update the project's source files.
        # Retrieve the current Commit ID of the selected Branch:
        $projectCommitIDOld = "$($gitControl.FetchCommitID("$($userPreferences.GetProjectPath())"))";


        # Show the user the current operation that is about to take place
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Updating $([ProjectInformation]::projectName)'s source files. . .");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Current Local Repository Commit ID: $($projectCommitIDOld)");


        # Try to update the local repository
        if (!$gitControl.UpdateLocalRepository($userPreferences.GetProjectPath()))
        {
            # Show to the user that there was an error while attempting to update the local repository
            [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Failure, "An error had occurred while updating your copy of $([ProjectInformation]::projectName)!");
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "If incase you made changes with the files, you may need to commit them before losing your work!");
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "If incase you not made any changes, you will need validate your Local Repository against the Remote Repository using Git!");
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("An error had occurred while updating your copy of $([ProjectInformation]::projectName)!`r`n" + `
                                            "Please make sure of the following:`r`n" + `
                                            "`t- If incase you had made some changes to the $([ProjectInformation]::projectName)'s source files, be sure to commit your work or undo the changes!`r`n" + `
                                            "`t- If incase you had not made any changes to your copy of $([ProjectInformation]::projectName), then please validate your local copy of the project using Git SCM!`r`n" + `
                                            "Because there exists changes that is causing conflicts with the update, it is not possible to proceed forward with the update!");

            # Generate the initial message
            $logMessage = "Unable to update the user's local repository for $([ProjectInformation]::projectName)!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = "Make sure that all file conflicts at been corrected before proceeding.";


            # Pass the information to the logging system
            [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                        "$($logAdditionalMSG)", `   # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *




            # Because we had reached an error, we cannot proceed forward.
            return $false;
        } # If : Failed to update the Local Repository



        # Retrieve the new Commit ID of the Local Repository's current state.
        $projectCommitIDNew = "$($gitControl.FetchCommitID("$($userPreferences.GetProjectPath())"))";


        # Show that the project's files had been updated!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully updated the $([ProjectInformation]::projectName)'s source files!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "New Local Repository Commit ID: $($projectCommitIDNew)");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully updated the $([ProjectInformation]::projectName) local repository!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Previous Parent Commit ID: $($projectCommitIDOld) `r`n" + `
                            "New Parent Commit ID: $($projectCommitIDNew)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity("$($logMessage)", `           # Initial message
                                    "$($logAdditionalMSG)", `       # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # We successfully updated the user's local repository!
        return $true;
    } # UpdateProject()





   <# Generate Archive Filename
    # -------------------------------
    # Documentation:
    #  This function will allow the ability to automatically generate
    #   the archive filename.
    # -------------------------------
    #>
    hidden static [string] GenerateArchiveFileName()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This will hold the filename for the archive data file
        [string] $archiveFileName = $null;
        # ----------------------------------------



        # Show that we gathering filename information
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Gathering filename information. . .");



        # Determine the core file name of the archive data file.
        $archiveFileName = "$([ProjectInformation]::fileName)";




        # Show the filename that has been generated.
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully generated the filename!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "File Name is `"$($archiveFileName)`".");



        # Return the full archive data file
        return "$($archiveFileName)";
    } # GenerateArchiveFileName()






   <# Generate Output Path
    # -------------------------------
    # Documentation:
    #  This function will determine the final location as to where the compiled build will be
    #   located in the user's systems.  This will assure that development builds and production
    #   builds are not combined and mixed into one directory.  As such, this will help to keep
    #   the builds organized and prevent some human errors when trying to look for a particular
    #   build or version.
    # -------------------------------
    #>
    hidden static [string] GenerateOutputPath()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();
        # ----------------------------------------


        # Show that we determining the final output location
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Determining the Output Directory. . .");




        # Show that we had concluded the output directory and everything is finished!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "The compiled build will be stored under `"$($userPreferences.GetProjectBuildsPath())`"");


        # We will store the archive file in the output directory as-is
        return "$($userPreferences.GetProjectBuildsPath())";
    } # GenerateOutputPath()






   <# Compile Project
    # -------------------------------
    # Documentation:
    #  This function will try to compile the project's files into
    #   one archive datafile.  This will make it possible to easily
    #   distribute the project files to other users as well as
    #   make it available onto servers.
    # -------------------------------
    # Input:
    #  [string] Archive File Name
    #   The requested name of the archive data file that is going to be created.
    #  [string] (REFERENCE) File Path
    #   The final absolute path of the archive datafile.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Unable to compact the project files into an archive datafile.
    #   $true = Successfully compacted the project files into an archive datafile.
    # -------------------------------
    #>
    hidden static [bool] CompileProject([string] $archiveFileName,      # Requested archive datafile
                                        [ref] $filePath)                # Absolute Path of the Archive datafile
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();

        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Show that we are about to compact the project's source files into an archive datafile.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Compile $([ProjectInformation]::projectName)");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Compiling $([ProjectInformation]::projectName). . .");


        # Use the preferred compiler as requested by the user
        switch ($userPreferences.GetCompressionTool())
        {
            # dotNET Core Archive ZIP PowerShell Module
            ([UserPreferencesCompressTool]::InternalZip)
            {
                # Show that we are using the Archive ZIP Module
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::InProgress, "Compacting using the default compression software. . .");

                # Compact the files
                if (!$defaultCompress.CreateArchive($archiveFileName,
                                                    $userPreferences.GetProjectBuildsPath(),
                                                    $userPreferences.GetProjectPath(),
                                                    $filePath))
                {
                    # An error had been reached while compacting the project's files.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "An error occurred while compiling $([ProjectInformation]::projectName)!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please review the logs for more information!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("Failed to compile $([ProjectInformation]::projectName)!" + `
                                                    "Please inspect the logs for what could had caused the problem.");

                    # Generate the initial message
                    $logMessage = "An error had been reached while compiling $([ProjectInformation]::projectName)!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Compression Tool: Archive Module [Default]`r`n" + `
                                        "Archive File Name Requested: $($archiveFileName)`r`n" + `
                                        "Output Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                        "Project Path: $($userPreferences.GetProjectPath())`r`n" + `
                                        "Entire Path (Optional): $($filePath)");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                                "$($logAdditionalMSG)", `   # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *
                } # If : Compiling Project Reached an Error
            } # dotNET Core Archive ZIP PowerShell Module


            # 7Zip
            ([UserPreferencesCompressTool]::SevenZip)
            {
                # Show that we are using the 7Zip software
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::InProgress, "Compacting using the 7Zip compression software. . .");

                # Compact the files
                if (!$sevenZip.CreateArchive($archiveFileName,
                                            $userPreferences.GetProjectBuildsPath(),
                                            $userPreferences.GetProjectPath(),
                                            $filePath))
                {
                    # An error had been reached while compacting the project's files.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "An error occurred while compiling $([ProjectInformation]::projectName)!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please review the logs for more information!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("Failed to compile $([ProjectInformation]::projectName)!" + `
                                                    "Please inspect the logs for what could had caused the problem.");

                    # Generate the initial message
                    $logMessage = "An error had been reached while compiling $([ProjectInformation]::projectName)!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Compression Tool: 7Zip`r`n" + `
                                        "Archive File Name Requested: $($archiveFileName)`r`n" + `
                                        "Output Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                        "Project Path: $($userPreferences.GetProjectPath())`r`n" + `
                                        "Entire Path (Optional): $($filePath)");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                                "$($logAdditionalMSG)", `   # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *
                } # If : Compiling Project Reached an Error
            } # 7Zip


            # Error Case
            default
            {
                # Show that we could not determine the preferred compression tool
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unknown or unsupported preferred compression software!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("Unable to compile $([ProjectInformation]::projectName)!" + `
                                                "The compression tool is unknown or unrecognizable");

                # Generate the initial message
                $logMessage = "Cannot compile the $([ProjectInformation]::projectName) project due to an unknown Compression Tool!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Compression Tool: $($userPreferences.GetCompressionTool())`r`n" + `
                                    "Archive File Name Requested: $($archiveFileName)`r`n" + `
                                    "Output Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                    "Project Path: $($userPreferences.GetProjectPath())");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                            "$($logAdditionalMSG)", `   # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage("$($displayErrorMessage)", `  # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # * * * * * * * * * * * * * * * * * * *
            } # Error Case
        } # Switch: Compile Project


        # If we made it this far, that means that the operation was successful!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully compiled $([ProjectInformation]::projectName)!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully compiled the $([ProjectInformation]::projectName) project!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Compression Tool: $($userPreferences.GetCompressionTool())`r`n" + `
                            "Archive File Name Requested: $($archiveFileName)`r`n" + `
                            "Output Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                            "Project Path: $($userPreferences.GetProjectPath())" + `
                            "Entire Path: $($filePath)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity("$($logMessage)", `       # Initial message
                                    "$($logAdditionalMSG)", `   # Additional information
                                    [LogMessageLevel]::Verbose);  # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful
        return $true;
    } # CompileProject()





   <# Test Compiled Build
    # -------------------------------
    # Documentation:
    #  This function will perform a test against the newly compiled
    #   archive datafile, such that we may assure that the build is
    #   healthy and consumable upon request.  If the build is damaged
    #   during the compiling phase, then this function will report
    #   that the build is not healthy - in which the user will need to
    #   take specific action regarding that build if necessary.
    # -------------------------------
    # Input:
    #  [string] Compiled Build Full Path
    #   The requested archive datafile that will be tested; absolute
    #    full path is required.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = The archive datafile is damaged or corrupted.
    #   $true  = The archive datafile is healthy
    #               OR
    #            User did not want to test the archive datafile.
    # -------------------------------
    #>
    hidden static [bool] TestCompiledBuild([string] $compiledBuildFullPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object;
        #  this contains the user's generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();


        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();


        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();


        # This will store the exit condition provided by the test function.
        [bool] $result = $false;
        # ----------------------------------------




        # Did the user wanted us to check the health of the archive datafile?
        if (!((($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::InternalZip) -and $defaultCompress.GetVerifyBuild()) -or `
            (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::SevenZip) -and $sevenZip.GetVerifyBuild())))
        {
            # Even though we did not perform the check, we will still return a successful signal to keep the process running.
            return $true;
        } # if : Do Not Check Build Health




        # Show that we are about to check the compiled build's health
        #  and integrity of its data structure.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Checking the archive file's health");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "File to inspect: $($compiledBuildFullPath)");


        # Let the user know that the test is starting
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Checking build. . .");



        # Perform the test.
        #  Default Compression Tool
        if (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::InternalZip) -and $defaultCompress.GetVerifyBuild())
        {
            # Check the compiled build using the Archive Module
            $result = $defaultCompress.VerifyArchive("$($compiledBuildFullPath)");
        } # if : Testing with Default Compression Tool

        # 7Zip Compression Tool
        elseif (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::SevenZip) -and $sevenZip.GetVerifyBuild())
        {
            # Check the compiled build using the 7Zip extCMD
            $result = $sevenZip.VerifyArchive("$($compiledBuildFullPath)");
        } # elseif : Testing with 7Zip Compression Tool

        # Unknown Case
        else
        {
            # Unknown condition was reached
            [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Error, "Unable to check the file's health and data structure integrity!");

            # Because an error had been reached, we will have to abort the operation
            return $false;
        } # else : Unknown Case \ Error Case



        # Show that the operation was completed successfully
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully checked compiled build's health!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Result was: $([string] $result)");


        # Return the result back to the calling function
        return $result;
    } # TestCompiledBuild()
   <# Display Bullet List Message
    # -------------------------------
    # Documentation:
    #  This function will act as a gateway into accessing the Formatted List.
    # -------------------------------
    # Input:
    #  [unsigned int] Message Position
    #   The position of the message that is to be displayed.  The position entails
    #       as to how many indentions are required before displaying the message.
    #  [FormattedListBuilder] Message Type
    #   The type of message that is to be presented to the user.  This usually could
    #   be a simple bullet list or provides a unique character for the message based
    #   on certain events.
    #  [string] Message String
    #   The message that will be displayed to the user.
    # -------------------------------
    #>
    hidden static [void] DisplayBulletListMessage([uint] $messagePosition,              # How many indentions before message
                                        [FormattedListBuilder] $messageType,    # Type of list or message
                                        [string] $messageString)                # Initial message to display
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This will hold the desired bullet point symbol or any special symbol
        #  that matches with the type of the message.
        [char] $bulletCharacter = $null;

        # Symbols that will be used when providing a list.
        [char] $symbolParent     = '>';     # Main Operation
        [char] $symbolChild      = '-';     # Sub-Main Operation
        [char] $symbolInProgress = '-';     # Task presently running
        [char] $symbolSuccessful = '-';     # Operation finished successfully
        [char] $symbolWarning    = '!';     # Reached a warning case
        [char] $symbolFailure    = '!';     # Operation reached an error
        # ----------------------------------------



        # Determine which symbol to use
        switch ($messageType)
        {
            # Parent
            ([FormattedListBuilder]::Parent)
            {
                # Use the Parent Symbol
                $bulletCharacter = $symbolParent;

                # Finished
                break;
            } # Parent


            # Child
            ([FormattedListBuilder]::Child)
            {
                # Use the Child Symbol
                $bulletCharacter = $symbolChild;

                # Finished
                break;
            } # Child


            # In-Progress
            ([FormattedListBuilder]::InProgress)
            {
                # Use the In-Progress Symbol
                $bulletCharacter = $symbolInProgress;

                # Finished
                break;
            } # In-Progress


            # Successful
            ([FormattedListBuilder]::Successful)
            {
                # Use the Successful Symbol
                $bulletCharacter = $symbolSuccessful;

                # Finished
                break;
            } # Successful


            # Warning
            ([FormattedListBuilder]::Warning)
            {
                # Use the Warning Symbol
                $bulletCharacter = $symbolWarning;

                # Finished
                break;
            } # Warning


            # Failure
            ([FormattedListBuilder]::Failure)
            {
                # Use the Failure Symbol
                $bulletCharacter = $symbolFailure;

                # Finished
                break;
            } # Failure


            # No Symbol
            default
            {
                # Do not use a symbol
                break;
            } # No Symbol
        } # Switch : Determine Symbol to Use



        # Provide the message
        [CommonCUI]::DrawFormattedList($messagePosition,    # How many spaces to indent the message
                                        $bulletCharacter,   # What symbol to use (optional)
                                        $messageString);    # Message to display
    } # DisplayBulletListMessage()
} # Builder




<# Builder Formatted List [ENUM]
 # -------------------------------
 # This will allow the ability to organize the type of messages that will be
 #  used within the Builder.
 # -------------------------------
 #>
 enum FormattedListBuilder
 {
     Parent         = 0; # Main Operation
     Child          = 1; # Sub-Operation
     InProgress     = 2; # Current Action
     Successful     = 3; # Operation was successful
     Warning        = 4; # A Warning had been raised
     Failure        = 5; # Operation had reached a failure
     NoSymbol       = 6; # No Symbol provided
 } # FormattedListBuilder
