<# Builder
 # ------------------------------
 # ==============================
 # ==============================
 # This class is the heart of the program - in which it allows the
 #  desired project to be compiled into a single archive data file.
 #  The builder will perform various steps to assure that the project
 #  is up to date with the remote repository, assure that all of the
 #  dependencies are ready for use, perform the compiling operation,
 #  verify the integrity of the newly generated archive datafile,
 #  and create any useful documentation as requested.  The user has
 #  full flexibility as to how the Builder operates and with what
 #  capabilities are usable.
 #>



class Builder
{
   <# Build
    # -------------------------------
    # Documentation:
    #  This function is essentially our main driver into creating a
    #   ZDoom based archive datafile generated by using the project's
    #   source files.  Because this function is our main driver into
    #   achieving this goal, we have to assure that the process is
    #   well organized and is keeping the operation - easy to manage.
    #   By doing this, we will want to approach this in a sequential
    #   manner while also checking our work consistently.  Meaning,
    #   in order to compile the project's source files into one single
    #   archive file, we may need to update the source via a Source
    #   Control tool - then we may proceed with compacting the data.
    #   This is only a brief example out of many possible cases now
    #   and as well in the future when and if the functionality were
    #   to expand.
    # -------------------------------
    # Input:
    #  [bool] Make Development Build
    #   When this flag is true, this will allow the ability create
    #   a developmental build of the project.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = The Project Build had reached an error.
    #   $true = The Project Build had successfully been created.
    # -------------------------------
    #>
    static [bool] Build([bool] $makeDevBuild)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Archive datafile's final destination path
        [string] $compiledBuildPath = $null;

        # The file name for the archive datafile.
        [string] $fileName = $null;

        # The Temporary Directory path that will hold the
        #  project's contents.
        [string] $projectTemporaryPath = $null;
        # ----------------------------------------


        # Clear the terminal of all previous text; keep the space clean so that
        #  it is easy for the user to read and follow along.
        [CommonIO]::ClearBuffer();


        # Draw Program Information Header
        [CommonCUI]::DrawProgramTitleHeader();


        # Show the user that they are at the Main Menu
        [CommonCUI]::DrawSectionHeader("Compiling the $([ProjectInformation]::projectName) [$([ProjectInformation]::codeName)] Project");


        # Display the instructions
        [CommonCUI]::CompileInstructions();





        #           Prerequisite Check
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Make sure that we have all of the resources that we are going to
        #  need in order to successfully compile this project.
        if (![Builder]::PrerequisiteCheck())
        {
            # Because we are lacking a required resource, we cannot proceed with
            #  this process.
            return $false;
        } # if : Evaluate Prerequisite Check


        # Because we have all of the resources that we need - in order to compile
        #  this project, we can proceed to the next step!





        #        Generate Output Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *
        # Determine and generate the output directory in which this compiled
        #  build will be stored.

        $compiledBuildPath = [Builder]::GenerateOutputPath();





        #           Update Source (Git)
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to update the user's copy of the project files.
        if (![Builder]::UpdateProject())
        {
            # Because there was an error while attempting to update the user's
            #  local copy of the project files, we cannot proceed.
            return $false;
        } # if : Update Local Project Files





        #            Generate Filename
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # We will need to know the file name that will identify archive datafile,
        #  as well as the file extension that will help to classify the archive
        #  datafile's data structure.
        $fileName = [Builder]::GenerateArchiveFileName($makeDevBuild);





        #         Create Temporary Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to create a new temporary directory, such that we may manipulate or
        #  alter the files if necessary - without having to change the state or
        #  lose files within the user's local copy of the project.
        if (![Builder]::CreateProjectTemporaryDirectory([ref] $projectTemporaryPath))
        {
            # Because there was an error while to create a new unique temporary directory,
            #  we cannot proceed forward with the operation.  Thus, we will have to abort
            #  the procedure.
            return $false;
        } # if : Cannot Create Temporary Directory





        #             Compile Project
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to compact the project files into an archive datafile.
        if (![Builder]::CompileProject($fileName, `             # Archive filename
                                    [ref]$compiledBuildPath, `  # Archive file location (output file)
                                    $projectTemporaryPath))     # Project's absolute path
        {
            # Because there was an error while compiling the project's source
            #  files, we will have to abort at this point.
            return $false;
        } # if : Compile Project





        #         Delete Temporary Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to delete the temporary directory that was previously created, as
        #  we no longer require that resource anymore for this operation.
        if (![Builder]::DeleteProjectTemporaryDirectory($projectTemporaryPath))
        {
            # Because there was an error while trying to delete the temporary directory,
            #  we will land in this condition, but we may proceed onward regardless.
            # The Operating System may try to remove the directory in a later date by
            #  default.
            ;
        } # if : Cannot Create Temporary Directory





        #               Test Build
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to test the archive data file to assure that it is not damaged.
        if (![Builder]::TestCompiledBuild($compiledBuildPath))
        {
            # Because the archive datafile is damaged or corrupted, we will have
            #  to abort the operation as we reached an error.
            return $false;
        } # if : Test Compiled Build





        #            Generate Reports
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to generate report based on the archive data file.
        if (![Builder]::GenerateReportArchiveDataFile($compiledBuildPath))
        {
            # Because we could not generate a report of the archive data file, the
            #  file might had been damaged or is corrupted.
            return $false;
        } # if : Generate Report Failed for Archive File


        # True to generate a report based on the Local Repository.
        if (![Builder]::GenerateReportProjectLocalRepository())
        {
            # Because we could not generate a report of the project's local
            #  repository, then the compiled project might had been damaged.
            return $false;
        } # if : Generate Report Failed for Local Repo. Project





        #          Show Project Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Now that we are finished, show the user where their compiled build
        #  is within the host's filesystem.
        [Builder]::ShowProjectLocation($compiledBuildPath);





        # Alert the user that the operation had finished
        [Notifications]::Notify([NotificationEventType]::Success);


        # Show that the compiling operation was successful.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Operation had been completed!");


        # Operation was successful!
        return $true;
    } # Build()




   <# Prerequisite Check
    # -------------------------------
    # Documentation:
    #  This function performs a validation check to assure that all
    #   of the required resources are available for the compiling
    #   process.  If incase we found one or more resources - that
    #   is imperative for the entire operation to work correctly -
    #   then we may ultimately abruptly abort the entire compile
    #   operation.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = One or more resources were missing but required.
    #   $true = All of the resources were accounted for and ready.
    # -------------------------------
    #>
    hidden static [bool] PrerequisiteCheck()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's Git Control object; this contains the user's
        #  preferences as to how Git will be used within this application.
        [GitControl] $gitControl = [GitControl]::GetInstance();

        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();

        # We will use this variable to cache the detection status of a particular item that we want
        #  to check.  Instead of having to recall the exact same checking function over and over again,
        #  we will use this variable to merely cache the value as we step through each process within
        #  the checking procedure.
        [bool] $boolCacheValue = $false;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # Show that the Prerequisite functionality is presently active
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Prerequisite Check");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Performing a Prerequisite Check. . .");



        #              Project Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Project Path
        $boolCacheValue = [CommonIO]::CheckPathExists($userPreferences.GetProjectPath(), $true);

        # Can we find the project's source files?
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the project's source files; unable to continue.

            # Alert the user that an error had been reached.
            [Notifications]::Notify([NotificationEventType]::Error);


            # Show that the Project's source files could not be found.
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find $([ProjectInformation]::projectName) source files!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the program settings!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I am unable to find the $([ProjectInformation]::projectName) source files!`r`n" + `
                                            "Please reconfigure the path for the $([ProjectInformation]::projectName) project!`r`n" + `
                                            "`t- $([ProjectInformation]::projectName) Project Path is presently: $($userPreferences.GetProjectPath())`r`n" + `
                                            "`t- Path Exists Detection Status: $([string]$boolCacheValue)");

            # Generate the initial message
            $logMessage = "Unable to find the $([ProjectInformation]::projectName) project's source files!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please reconfigure the location of the $([ProjectInformation]::projectName) Project's Source.`r`n" + `
                                "`tProject Source Location is: $($userPreferences.GetProjectPath())`r`n" + `
                                "`tProject Source Path Exists: $([string]$boolCacheValue)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the project's source files, we have to abort the operation.
            return $false;
        } # if : Check Project source files exists



        # Successfully found project files
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the $([ProjectInformation]::projectName) source files!");




        #              Output Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Output Path
        $boolCacheValue = [CommonIO]::CheckPathExists($userPreferences.GetProjectBuildsPath(), $true);

        # Can we find the output path?
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the output path directory; unable to continue.

            # Alert the user that an error had been reached.
            [Notifications]::Notify([NotificationEventType]::Error);


            # Show that the Output Directory could not be found.
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the Output Directory!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the Program's Generalized Settings!");
            [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I cannot find the folder to store any new compiled builds!`r`n" + `
                                            "Please reconfigure the Output Path in the program's general settings!`r`n" + `
                                            "`t- Output Path is presently: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                            "`t- Path Exists Detection Status: $([string]$boolCacheValue)");

            # Generate the initial message
            $logMessage = "Unable to find the Output Directory!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please reconfigure the location of the Output Directory.`r`n" + `
                                "`tOutput Directory Location is: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                "`tOutput Directory Path Found: $([string]$boolCacheValue)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `   # Message to display
                                    [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the output directory, we have no place to place the
            #  compiled build.  We cannot continue this operation.
            return $false;
        } # if : Check Output Path exists



        # Successfully found output directory
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the Output Directory!");




        #            Compression Tool
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Determine if the chosen compression tool is available for us to utilize.
        switch ($userPreferences.GetCompressionTool())
        {
            # dotNET Archive Zip
            ([UserPreferencesCompressTool]::InternalZip)
            {
                # Check the current status of the Archive ZIP Module
                $boolCacheValue = [CommonFunctions]::IsAvailableZip();

                # Make sure that the dotNET Archive Zip is available
                if ($boolCacheValue -eq $false)
                {
                    # Unable to find the dotNET Archive Zip

                    # Alert the user that an error had been reached.
                    [Notifications]::Notify([NotificationEventType]::Error);


                    # Show that this program cannot detect the dotNET Core Archive ZIP functionality.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find native support with Default ZIP functionality");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you are using the latest version of PowerShell Core!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("I am unable to find support for ZIP in this version of PowerShell!`r`n" + `
                                                    "Please make sure that you are using the latest version of PowerShell Core!`r`n" + `
                                                    "`t- You are currently using PowerShell Core Version: $([SystemInformation]::PowerShellVersion())`r`n" + `
                                                    "`t- ZIP Archive Module Detection Status: $([string]$boolCacheValue)`r`n" + `
                                                    "`t- You may check out any new releases of the PowerShell Core at GitHub!`r`n" + `
                                                    "`t`thttps://github.com/PowerShell/PowerShell/releases");

                    # Generate the initial message
                    $logMessage = "Unable to find the dotNET Archive Zip Module!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Please assure that you are currently using the latest version of PowerShell Core!`r`n" + `
                                        "`tArchive ZIP Module Detection reported: $([string]$boolCacheValue)`r`n" + `
                                        "`tPowerShell Version: $([SystemInformation]::PowerShellVersion())`r`n" + `
                                        "`tOperating System: $([String][SystemInformation]::OperatingSystem())`r`n" + `
                                        "`tCheck for new versions of PowerShell Core at the provided official website:`r`n" + `
                                        "`t`thttps://github.com/PowerShell/PowerShell/releases");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                                $logAdditionalMSG, `        # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *


                    # Because we cannot find the default internal Archive Module within PowerShell, we
                    #  cannot proceed forward with the compiling phase.
                    return $false;
                } # If : Found Default Zip


                # Successfully found native support with the Archive ZIP module
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found native support with dotNET Core Archive ZIP!");


                # Finished
                break;
            } # dotNET Archive Zip


            # 7Zip
            ([UserPreferencesCompressTool]::SevenZip)
            {
                # Check the current status of the 7Zip application
                $boolCacheValue = [CommonFunctions]::IsAvailable7Zip();

                # Make sure that the 7Zip is available
                if ($boolCacheValue -eq $false)
                {
                    # Unable to find the 7Zip application

                    # Alert the user that an error had been reached.
                    [Notifications]::Notify([NotificationEventType]::Error);


                    # Show that this program cannot find the 7Zip software installed on this system or the desired location.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the 7Zip application installed!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you have 7Zip installed and that this program can find it as well.");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("I am unable to find the 7Zip software on your computer!`r`n" + `
                                                    "Please assure that 7Zip had been properly installed on your computer!`r`n" + `
                                                    "`t- 7Zip Detection Status: $([string]$boolCacheValue)`r`n" + `
                                                    "`t- You may download the latest version of 7Zip at the official website!`r`n" + `
                                                    "`t`thttps://www.7-zip.org/download.html");

                    # Generate the initial message
                    $logMessage = "Unable to find the 7Zip Application!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Please assure that you currently have 7Zip installed and that $($Global:_PROGRAMNAME_) can detect it's installation path!`r`n" + `
                                        "`tFound 7Zip: $([String]$boolCacheValue)`r`n" + `
                                        "`t7Zip Path: $($sevenZip.GetExecutablePath())`r`n" + `
                                        "`tInstall the latest version of 7Zip at the official website:`r`n" + `
                                        "`t`thttps://www.7-zip.org/download.html");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                                $logAdditionalMSG, `        # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *


                    # Because the user specified that we must use 7Zip in order to compile the builds,
                    #  then we must abort the operation as we are unable to find the software.
                    return $false;
                } # If : Found 7Zip


                # Successfully found 7Zip
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the 7Zip Application!");


                # Finished
                break;
            } # 7Zip


            # Unknown or Unsupported (Error Case)
            default
            {
                # Unknown or Unsupported compression tool!

                # Alert the user that an error had been reached.
                [Notifications]::Notify([NotificationEventType]::Error);


                # Show that the preferred compression tool is not valid.
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Preferred Compression Tool is not supported or I don't know what it is!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the Compression Tool within the Program Generalized Settings!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("Please choose a valid Compression Tool within the Program's Generalized settings!`r`n" + `
                                                "The current compression tool that you had requested is either no longer supported or unknown.`r`n" + `
                                                "`t- Current Compression Tool ID is: $([uint]$userPreferences.GetCompressionTool())");

                # Generate the initial message
                $logMessage = "Requested compression software is either unsupported or unknown!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Please reconfigure your preferred Compression Tool within the Program's Generalized Settings!`r`n" + `
                                    "`tCompression Tool ID: $([uint]$userPreferences.GetCompressionTool())");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                            $logAdditionalMSG, `        # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # * * * * * * * * * * * * * * * * * * *


                # Because this compression tool is not support or simply unknown, have to abruptly
                #  stop.
                return $false;
            } # Unknown or Unsupported
        } # Switch : Determine Specified Compression Tool




        #           Git Functionality
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Determine if the user wanted us to use Git Features
        if ($userPreferences.GetUseGitFeatures())
        {
            # Check the current status of the Git application
            $boolCacheValue = [CommonFunctions]::IsAvailableGit();

            # Assure that we are able to find the Git Application
            if ($boolCacheValue -eq $false)
            {
                # Unable to find the Git application.

                # Alert the user that an error had been reached.
                [Notifications]::Notify([NotificationEventType]::Error);


                # Show that the preferred compression tool is not valid.
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the Git SCM Version Control Application!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you have Git installed and that this program can find it as well.");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("I am unable to find the Git Version Control software on your computer!`r`n" + `
                                                "Please assure that Git Version Control had been properly installed on your computer!`r`n" + `
                                                "`t- Git Detection Status: $([string]$boolCacheValue)`r`n" + `
                                                "`t- You may download the latest version of Git at the official website!`r`n" + `
                                                "`t`thttps://git-scm.com/");

                # Generate the initial message
                $logMessage = "Unable to find the Git Application!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Please assure that you currently have Git installed and that $($Global:_PROGRAMNAME_) can detect it's installation path!`r`n" + `
                                    "`tFound Git: $([String]$boolCacheValue)`r`n" + `
                                    "`tGit Path: $($gitControl.GetExecutablePath())`r`n" + `
                                    "`tInstall the latest version of GIT at the official website:`r`n" + `
                                    "`t`thttps://git-scm.com/");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                            $logAdditionalMSG, `        # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # * * * * * * * * * * * * * * * * * * *


                # Because the user had requested that we utilize the Git software yet we are unable
                #  to find it, we may not continue with the compiling operation.
                return $false;
            } # if : Check if Git Exists



        # Successfully found Git SCM!
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the Git Application!");
        } # if : Git Features Requested




        #                  DONE!
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # If we made it this far, that means that we have everything we need to compile this project!


        # Show that the Perquisite Check had passed!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully found all the required resources!");




        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = ("The Prerequisite Check had determined that we have all of the required" + `
                        "resources necessary to compile the $([ProjectInformation]::projectName) project!");

        # Generate any additional information that might be useful
        $logAdditionalMSG = "Prerequisite Check had successfully passed!";

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # If we made it to this point, then we have all of the resources
        #  that we need to compile this project!
        return $true;
    } # PrerequisiteCheck()





   <# Git - Update Project
    # -------------------------------
    # Documentation:
    #  This function will update the project's source files by
    #   updating the local repository, which in turn - updates
    #   the local working copy files at the same time.  In which
    #   assures that the user has the latest version of the
    #   project files within the selected branch.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to update the project source files
    #   $true = Successfully updated the project source files
    # -------------------------------
    #>
    hidden static [bool] UpdateProject()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's Git Control object; this contains the user's
        #  preferences as to how Git will be used within this application.
        [GitControl] $gitControl = [GitControl]::GetInstance();

        # We will use this to hold the local repository's last branch update Commit ID.
        [string] $projectCommitIDNew = $NULL;           # Updated Local Repository Commit ID
        [string] $projectCommitIDOld = $NULL;           # Before the Update Commit ID


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # First we will want to make sure that the user wanted us to update the project's source files
        if (($userPreferences.GetUseGitFeatures() -and $gitControl.GetUpdateSource()) -eq $false)
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to update the $([ProjectInformation]::projectName) local repository!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("User's Preferences for using Git Features: $($userPreferences.GetUseGitFeatures())`r`n" + `
                                "`tGit's Settings for Updating Project Source: $($gitControl.GetUpdateSource())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because the user had requested that this step be skipped, then we will
            #  provide a successful signal.  Ideally, there was no error here, other
            #  than following the user's request.
            return $true;
        } # If : Do not update project source files




        # Show that we are about to update the project source files
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Update $([ProjectInformation]::projectName)");




        # If we made it this far, then we can try to update the project's source files.
        # Retrieve the current Commit ID of the selected Branch:
        $projectCommitIDOld = $gitControl.FetchCommitID($userPreferences.GetProjectPath());


        # Show the user the current operation that is about to take place
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Updating $([ProjectInformation]::projectName)'s source files. . .");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Current Local Repository Commit ID: $($projectCommitIDOld)");


        # Try to update the local repository
        if (!$gitControl.UpdateLocalRepository($userPreferences.GetProjectPath()))
        {
            # Reached an error while attempting to update the local repository.

            # Alert the user that an error had been reached.
            [Notifications]::Notify([NotificationEventType]::Error);


            # Show to the user that there was an error while attempting to update the local repository
            [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Failure, "An error had occurred while updating your copy of $([ProjectInformation]::projectName)!");
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "If incase you made changes with the files, you may need to commit them before losing your work!");
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "If incase you not made any changes, you will need validate your Local Repository against the Remote Repository using Git!");
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("An error had occurred while updating your copy of $([ProjectInformation]::projectName)!`r`n" + `
                                            "Please make sure of the following:`r`n" + `
                                            "`t- If incase you had made some changes to the $([ProjectInformation]::projectName)'s source files, be sure to commit your work or undo the changes!`r`n" + `
                                            "`t- If incase you had not made any changes to your copy of $([ProjectInformation]::projectName), then please validate your local copy of the project using Git SCM!`r`n" + `
                                            "Because there exists changes that is causing conflicts with the update, it is not possible to proceed forward with the update!");

            # Generate the initial message
            $logMessage = "Unable to update the user's local repository for $([ProjectInformation]::projectName)!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = "Make sure that all file conflicts at been corrected before proceeding.";


            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Because we had reached an error, we cannot proceed forward.
            return $false;
        } # If : Failed to update the Local Repository



        # Retrieve the new Commit ID of the Local Repository's current state.
        $projectCommitIDNew = $gitControl.FetchCommitID($userPreferences.GetProjectPath());


        # Show that the project's files had been updated!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully updated the $([ProjectInformation]::projectName)'s source files!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "New Local Repository Commit ID: $($projectCommitIDNew)");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully updated the $([ProjectInformation]::projectName) local repository!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Previous Parent Commit ID: $($projectCommitIDOld) `r`n" + `
                            "`tNew Parent Commit ID: $($projectCommitIDNew)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # We successfully updated the user's local repository!
        return $true;
    } # UpdateProject()





   <# Generate Archive Filename
    # -------------------------------
    # Documentation:
    #  This function will allow the ability to automatically generate
    #   the archive filename.
    # -------------------------------
    # Input:
    #  [bool] Make Development Build
    #   When this flag is true, this will append the latest git commit
    #   available within the user's local repository.  Only useful
    #   when wanting to create a specialized developmental build.
    # -------------------------------
    # Output:
    #   [string] Archive Datafile Name
    #       The name of the archive datafile that will be generated.
    # -------------------------------
    #>
    hidden static [string] GenerateArchiveFileName([bool] $makeDevBuild)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This will hold the filename for the archive data file
        [string] $archiveFileName = $null;

        # Retrieve the Git Control object
        [GitControl] $gitControl = [GitControl]::GetInstance();

        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();
        # ----------------------------------------



        # Show that we gathering filename information
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Gathering filename information. . .");



        # Apply the core filename of the archive datafile
        $archiveFileName = [ProjectInformation]::fileName;


        # Determine if we are to apply the git SHA1 onto the filename
        if ($makeDevBuild)
        {
            # Because we are constructing a developmental build of the project, we will append the SHA1 hash onto the filename.
            $archiveFileName += "-dev_" + $gitControl.FetchCommitID($userPreferences.GetProjectPath());
        } # if: Dev. Build Request



        # Show the filename that has been generated.
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully generated the filename!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "File Name is `"$($archiveFileName)`".");



        # Return the full archive data file
        return $archiveFileName;
    } # GenerateArchiveFileName()






   <# Generate Output Path
    # -------------------------------
    # Documentation:
    #  This function will determine the final location as to where the compiled build will be
    #   located in the user's systems.  This will assure that development builds and production
    #   builds are not combined and mixed into one directory.  As such, this will help to keep
    #   the builds organized and prevent some human errors when trying to look for a particular
    #   build or version.
    # -------------------------------
    #>
    hidden static [string] GenerateOutputPath()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();
        # ----------------------------------------


        # Show that we determining the final output location
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Determining the Output Directory. . .");


        # Show that we had concluded the output directory and everything is finished!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "The compiled build will be stored under `"$($userPreferences.GetProjectBuildsPath())`"");


        # We will store the archive file in the output directory as-is
        return $userPreferences.GetProjectBuildsPath();
    } # GenerateOutputPath()






   <# Compile Project
    # -------------------------------
    # Documentation:
    #  This function will try to compile the project's files into
    #   one archive datafile.  This will make it possible to easily
    #   distribute the project files to other users as well as
    #   make it available onto servers.
    # -------------------------------
    # Input:
    #  [string] Archive File Name
    #   The requested name of the archive data file that is going to be created.
    #  [string] (REFERENCE) File Path
    #   The final absolute path of the archive datafile.
    #  [string] Project Directory
    #   This is the location of where the 
    #   This provides the location of where the project files are located, this
    #   is usually in a unique temporary directory.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Unable to compact the project files into an archive datafile.
    #   $true = Successfully compacted the project files into an archive datafile.
    # -------------------------------
    #>
    hidden static [bool] CompileProject([string] $archiveFileName, `    # Requested archive datafile
                                        [ref] $filePath, `              # Absolute Path of the Archive datafile
                                        [string] $projectPath)          # Absolute Path of the Temporary Directory Project location
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();

        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Show that we are about to compact the project's source files into an archive datafile.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Compile $([ProjectInformation]::projectName)");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Compiling $([ProjectInformation]::projectName). . .");


        # Use the preferred compiler as requested by the user
        switch ($userPreferences.GetCompressionTool())
        {
            # dotNET Core Archive ZIP PowerShell Module
            ([UserPreferencesCompressTool]::InternalZip)
            {
                # Show that we are using the Archive ZIP Module
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::InProgress, "Compacting using the default compression software. . .");

                # Compact the files
                if (!$defaultCompress.CreateArchive($archiveFileName, `
                                                    $userPreferences.GetProjectBuildsPath(), `
                                                    $projectPath, `
                                                    $filePath))
                {
                    # Reached an error while trying to compact the files.

                    # Alert the user that an error had been reached.
                    [Notifications]::Notify([NotificationEventType]::Error);


                    # An error had been reached while compacting the project's files.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "An error occurred while compiling $([ProjectInformation]::projectName)!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please review the logs for more information!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("Failed to compile $([ProjectInformation]::projectName)!`r`n" + `
                                                    "Please inspect the logs for what could had caused the problem.");

                    # Generate the initial message
                    $logMessage = "An error had been reached while compiling $([ProjectInformation]::projectName)!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Compression Tool: Archive Module [Default]`r`n" + `
                                        "`tArchive File Name Requested: $($archiveFileName)`r`n" + `
                                        "`tOutput Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                        "`tProject Path: $($projectPath)`r`n" + `
                                        "`tEntire Path (Optional): $($filePath.Value)");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                                $logAdditionalMSG, `        # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *
                } # If : Compiling Project Reached an Error
            } # dotNET Core Archive ZIP PowerShell Module


            # 7Zip
            ([UserPreferencesCompressTool]::SevenZip)
            {
                # Show that we are using the 7Zip software
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::InProgress, "Compacting using the 7Zip compression software. . .");

                # Compact the files
                if (!$sevenZip.CreateArchive($archiveFileName, `
                                            $userPreferences.GetProjectBuildsPath(), `
                                            $projectPath, `
                                            $filePath))
                {
                    # Reached an error while trying to compact the files.

                    # Alert the user that an error had been reached.
                    [Notifications]::Notify([NotificationEventType]::Error);


                    # An error had been reached while compacting the project's files.
                    [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "An error occurred while compiling $([ProjectInformation]::projectName)!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please review the logs for more information!");
                    [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                    # * * * * * * * * * * * * * * * * * * *
                    # Debugging
                    # --------------

                    # Generate a message to display to the user.
                    [string] $displayErrorMessage = ("Failed to compile $([ProjectInformation]::projectName)!" + `
                                                    "Please inspect the logs for what could had caused the problem.");

                    # Generate the initial message
                    $logMessage = "An error had been reached while compiling $([ProjectInformation]::projectName)!";

                    # Generate any additional information that might be useful
                    $logAdditionalMSG = ("Compression Tool: 7Zip`r`n" + `
                                        "`tArchive File Name Requested: $($archiveFileName)`r`n" + `
                                        "`tOutput Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                        "`tProject Path: $($projectPath)`r`n" + `
                                        "`tEntire Path (Optional): $($filePath.Value)");

                    # Pass the information to the logging system
                    [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                                $logAdditionalMSG, `        # Additional information
                                                [LogMessageLevel]::Error);  # Message level

                    # Display a message to the user that something went horribly wrong
                    #  and log that same message for referencing purpose.
                    [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                                [LogMessageLevel]::Error);  # Message level

                    # * * * * * * * * * * * * * * * * * * *
                } # If : Compiling Project Reached an Error
            } # 7Zip


            # Error Case
            default
            {
                # Unknown Compression Tool

                # Alert the user that an error had been reached.
                [Notifications]::Notify([NotificationEventType]::Error);


                # Show that we could not determine the preferred compression tool
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unknown or unsupported preferred compression software!");
                [Builder]::DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("Unable to compile $([ProjectInformation]::projectName)!" + `
                                                "The compression tool is unknown or unrecognizable");

                # Generate the initial message
                $logMessage = "Cannot compile the $([ProjectInformation]::projectName) project due to an unknown Compression Tool!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Compression Tool: $($userPreferences.GetCompressionTool())`r`n" + `
                                    "`tArchive File Name Requested: $($archiveFileName)`r`n" + `
                                    "`tOutput Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                    "`tProject Path: $($projectPath)");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                            $logAdditionalMSG, `        # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # * * * * * * * * * * * * * * * * * * *
            } # Error Case
        } # Switch: Compile Project


        # If we made it this far, that means that the operation was successful!
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully compiled $([ProjectInformation]::projectName)!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully compiled the $([ProjectInformation]::projectName) project!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Compression Tool: $([string] $userPreferences.GetCompressionTool())`r`n" + `
                            "`tArchive File Name Requested: $($archiveFileName)`r`n" + `
                            "`tOutput Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                            "`tProject Path: $($projectPath)" + `
                            "`tEntire Path: $($filePath.Value)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful
        return $true;
    } # CompileProject()





   <# Create Project Temporary Directory
    # -------------------------------
    # Documentation:
    #  This function will try to assure that a new temporary directory
    #   had been created successfully.  This temporary directory is
    #   critical to the compiling process, as this will allow us the
    #   ability to modify the project files such that it will have no
    #   effect to original project files.
    #  Thus, if we need to alter the state of the project files,
    #   manipulate, configure, or remove certain files, we may do so
    #   while NOT changing the original source.
    # -------------------------------
    # Input:
    #  [string] (REFERENCE) Temporary Directory Path
    #   Once populated, this will hold the temporary directory location.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to create the temporary directory.
    #   $true  = Successfully created the temporary directory.
    # -------------------------------
    #>
    hidden static [bool] CreateProjectTemporaryDirectory([ref] $directoryPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This variable will provide the key term of the temporary directory
        #  to be created.
        [string] $directoryKeyTerm = $null;

        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # This function is going to be very basic, yet critical to assure that
        #  we may proceed forward with the operation.


        # Show that we trying to create a temporary directory
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Creating temporary directory. . .");


        # Generate the Key Term of the Temporary Directory
        $directoryKeyTerm = "Compile " + [ProjectInformation]::fileName;


        # Create the temporary directory
        if (![CommonIO]::MakeTempDirectory($directoryKeyTerm, $directoryPath))
        {
            # Failed to create the temporary directory!

            # Alert the user that an error had been reached
            [Notifications]::Notify([NotificationEventType]::Error);


            # Show the user that an error had been reached while creating the temporary directory.
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to create the temporary directory!");


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I was unable to create the project's temporary directory.`r`n" + `
                                            "Make sure that you have sufficient privileges to create a temporary directory.");

            # Generate the initial message
            $logMessage = "Unable to create a temporary directory for the $([ProjectInformation]::projectName) source files!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please assure that you have sufficient privileges to create a temporary directory.`r`n" + `
                                "`tTemporary File Root Location: $($env:TEMP)`r`n" + `
                                "`tTemporary Directory Key Term: $($directoryKeyTerm)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *
            
            
            
            # Operation had failed
            return $false;
        } # if : Failed to Create Temp. Directory



        # Successfully created the temporary directory
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully created a temporary directory!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Temporary Directory Path is: " + $directoryPath.Value);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully created a temporary directory for the $([ProjectInformation]::projectName) source files!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Temporary File Root Location: $($env:TEMP)`r`n" + `
                            "`tTemporary Directory Key Term: $($directoryKeyTerm)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                    $logAdditionalMSG, `        # Additional information
                                    [LogMessageLevel]::Verbose);  # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful!
        return $true;
    } # CreateProjectTemporaryDirectory()





   <# Delete Project Temporary Directory
    # -------------------------------
    # Documentation:
    #  This function will delete the temporary directory that was previously
    #   created in order to compile the project with special instructions,
    #   in which does not effect the original project source files.
    # -------------------------------
    # Input:
    #  [string] Temporary Directory Path
    #   This provides the temporary directory path that is to be expunged.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to delete the temporary directory.
    #   $true  = Successfully deleted the temporary directory.
    # -------------------------------
    #>
    hidden static [bool] DeleteProjectTemporaryDirectory([string] $projectTemporaryPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Show that we trying to delete the temporary directory
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Deleting temporary directory. . .");


        if (![CommonIO]::DeleteDirectory($projectTemporaryPath))
        {
            # Failed to delete the temporary directory


            # Alert the user that an error had been reached
            [Notifications]::Notify([NotificationEventType]::Warning);


            # Show the user than an error had been reached while deleting the temporary directory.
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Warning, "Unable to delete the temporary directory!");


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I was unable to delete the project's temporary directory.`r`n" + `
                                            "Make sure that you have sufficient privileges to delete the temporary directory.");

            # Generate the initial message
            $logMessage = "Unable to delete the temporary directory!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please assure that you have sufficient privileges to delete a temporary directory.`r`n" + `
                                "If the directory cannot be discarded, then the Operating System may do so automatically in a later time.`r`n" + `
                                "`tTemporary File Root Location: $($env:TEMP)`r`n" + `
                                "`tTemporary Directory Location: $($projectTemporaryPath)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Warning);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Warning);  # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Operation had failed
            return $false;
        } # if: Failed to Delete Directory



        # Successfully created the temporary directory
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully deleted the temporary directory!");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Temporary Directory Path that was Deleted: " + $projectTemporaryPath);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully deleted the temporary directory!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Temporary File Root Location: $($env:TEMP)`r`n" + `
                            "`tTemporary Directory Location: $($projectTemporaryPath)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                    $logAdditionalMSG, `        # Additional information
                                    [LogMessageLevel]::Verbose);  # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful!
        return $true;
    } # # DeleteProjectTemporaryDirectory()





   <# Test Compiled Build
    # -------------------------------
    # Documentation:
    #  This function will perform a test against the newly compiled
    #   archive datafile, such that we may assure that the build is
    #   healthy and consumable upon request.  If the build is damaged
    #   during the compiling phase, then this function will report
    #   that the build is not healthy - in which the user will need to
    #   take specific action regarding that build if necessary.
    # -------------------------------
    # Input:
    #  [string] Compiled Build Full Path
    #   The requested archive datafile that will be tested; absolute
    #    full path is required.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = The archive datafile is damaged or corrupted.
    #   $true  = The archive datafile is healthy
    #               OR
    #            User did not want to test the archive datafile.
    # -------------------------------
    #>
    hidden static [bool] TestCompiledBuild([string] $compiledBuildFullPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object;
        #  this contains the user's generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();


        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();


        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();


        # This will store the exit condition provided by the test function.
        [bool] $result = $false;


        # This is equivalent to the result [boolean], but this will be displayed onto the terminal.
        #  We will populated this value with a default value with 'Failed'.  We will update this value
        #  if the test indicated that the build is healthy.
        [string] $resultNiceValue = "Damaged; not healthy";


        # With this variable, we can adjust the symbol that is provided when providing
        #  the bullet message to the user.  By default, we will focus on the error.
        [FormattedListBuilder] $resultSymbol = [FormattedListBuilder]::Failure;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # Did the user wanted us to check the health of the archive datafile?
        if (!((($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::InternalZip) -and $defaultCompress.GetVerifyBuild()) -or `
            (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::SevenZip) -and $sevenZip.GetVerifyBuild())))
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to check the health of the archive data file!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Desired Compression Tool: $([string]$userPreferences.GetCompressionTool())`r`n" + `
                                "`tDefault Compression Verify Setting: $([string]$defaultCompress.GetVerifyBuild())`r`n" + `
                                "`t7Zip Verify Setting: $([string]$sevenZip.GetVerifyBuild())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Even though we did not perform the check, we will still return a successful signal to keep the process running.
            return $true;
        } # if : Do Not Check Build Health




        # Show that we are about to check the compiled build's health
        #  and integrity of its data structure.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Checking the archive file's health");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "File to inspect: $($compiledBuildFullPath)");


        # Let the user know that the test is starting
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Checking build. . .");



        # Perform the test.
        #  Default Compression Tool
        if (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::InternalZip) -and $defaultCompress.GetVerifyBuild())
        {
            # Check the compiled build using the Archive Module
            $result = $defaultCompress.VerifyArchive($compiledBuildFullPath);
        } # if : Testing with Default Compression Tool

        # 7Zip Compression Tool
        elseif (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::SevenZip) -and $sevenZip.GetVerifyBuild())
        {
            # Check the compiled build using the 7Zip extCMD
            $result = $sevenZip.VerifyArchive($compiledBuildFullPath);
        } # elseif : Testing with 7Zip Compression Tool

        # Unknown Case
        else
        {
            # Unable to determine the selected compression tool

            # Alert the user that an error had been reached.
            [Notifications]::Notify([NotificationEventType]::Error);


            # Unknown condition was reached
            [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Error, "Unable to check the file's health and data structure integrity!");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("An error had occur while attempting to verify the archive data file!`r`n" + `
                                            "Please assure that you had specified if you want the archive file to be tested.");

            # Generate the initial message
            $logMessage = "Unable to verify the archive data file due to an unknown or special rare event.";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Desired Compression Tool: $([string]$userPreferences.GetCompressionTool())`r`n" + `
                                "`tDefault Compression Verify Setting: $([string]$defaultCompress.GetVerifyBuild())`r`n" + `
                                "`t7Zip Verify Setting: $([string]$sevenZip.GetVerifyBuild())");


            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Because an error had been reached, we will have to abort the operation
            return $false;
        } # else : Unknown Case \ Error Case


        # Revise the Nice Result such that we indicate that the build is healthy
        if ($result)
        {
            # We will show that the build is healthy
            $resultNiceValue = "Healthy";

            # Revise the symbol such that we do not push an error symbol
            $resultSymbol = [FormattedListBuilder]::Child;
        } # if : Archive is Healthy

        # If the build is corrupted, we will notify the user by audible notification.
        else
        {
            # Build is not healthy

            # Alert the user that the build is not healthy.
            [Notifications]::Notify([NotificationEventType]::Warning);
        } # else : Build is Not Healthy



        # Show that the operation was successful and provide the condition of the build
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully checked compiled build's health!");
        [Builder]::DisplayBulletListMessage(2, $resultSymbol, "The compiled build is: " + $resultNiceValue + "!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully checked the archive file; health of the build is [$($resultNiceValue)]!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Archive file checked: $($compiledBuildFullPath)`r`n" + `
                            "`tNice Result Provided: $($resultNiceValue)`r`n" + `
                            "`tResult Given: $($result)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # Return the result back to the calling function
        return $result;
    } # TestCompiledBuild()





   <# Generate Report: Archive Data File
    # -------------------------------
    # Documentation:
    #  This function will try to create a report regarding the newly
    #   compiled archive datafile.  This will provide a thorough
    #   outlook regarding information about the file itself as well
    #   as the contents within the archive datafile.
    # -------------------------------
    # Input:
    #  [string] Compiled Build Full Path
    #   The requested archive datafile that will be tested; absolute
    #    full path is required.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to create the desired report
    #   $true  = Successfully created the requested report
    # -------------------------------
    #>
    hidden static [bool] GenerateReportArchiveDataFile([string] $compiledBuildFullPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's 7Zip object; this contains the user's
        #  preferences as to how 7Zip will be utilized within this application.
        [SevenZip] $sevenZip = [SevenZip]::GetInstance();

        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();

        # This will store the exit condition provided by the test function.
        [bool] $result = $false;

        # This is equivalent to the result [boolean] variable, but this will be displayed onto the
        #  terminal.  We will populate this value with a default value signifying that it had failed.
        #  However, we will update this value if the resulting operation was successful.
        [string] $resultNiceValue = "Failed to create the report on the archive file!";

        # With this variable, we can adjust the symbol that is provided when issuing the bullet
        #  message to the user.  By default, we will use an error - but change it later if the
        #  operation was successful.
        [FormattedListBuilder] $resultSymbol = [FormattedListBuilder]::Failure;

        # With this variable, we may easily determine if the user wanted to utilize the default
        #  compression or the 7Zip compression object to generate the report.
        [char] $compressionTool = $null;

        # When populated, these variables will hold the absolute paths of the generated report files.
        #  - Text Report File
        [string] $fullPathReportTextFile = $null;
        #  - PDF Report File
        [string] $fullPathReportPDFFile = $null;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Determine if the user wanted a report generated and with what compression tool.
        #  Did the user wanted Default Compression and generate report?
        if (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::InternalZip) -and $defaultCompress.GetGenerateReport())
        {
            # User wanted a report generated using the Default Compression object.
            $compressionTool = 'D';
        } # if : Generate Report using Default Compression Tool
        #  Did the user wanted 7Zip Compression and generate report?
        elseif (($userPreferences.GetCompressionTool() -eq [UserPreferencesCompressTool]::SevenZip) -and $sevenZip.GetGenerateReport())
        {
            # User wanted a report generated using the 7Zip Compression object.
            $compressionTool = '7';
        } # if : Generate Report using 7Zip Compression Tool
        #  User does not want a report to be generated.
        else
        {
            # User does not want a report generated.



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to generate a report on the archive data file!";

            # Generate any additional information that might be useful
             $logAdditionalMSG = ("Desired Compression Tool: $([string]$userPreferences.GetCompressionTool())`r`n" + `
                                "`tDefault Compression Generate Report Setting: $([string]$defaultCompress.GetGenerateReport())`r`n" + `
                                "`t7Zip Generate Report Setting: $([string]$sevenZip.GetGenerateReport())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Even though we did not perform the check, we will still return a successful signal to keep the process running.
            return $true;
        } # else : Do not generate report




        # Show that we are about to generate a report of the archive data file
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Generating report of the archive file");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "Report will be based on this archive file: " + $compiledBuildFullPath);


        # Let the user know that the report is being created
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Generating report. . .");


        # Generate the report
        #  Default Compression Tool
        if ($compressionTool -eq 'D')
        {
            # Generate a report using the default compression tool
            $result = $defaultCompress.CreateNewReport($compiledBuildFullPath, `
                                                        [ref] $fullPathReportTextFile, `
                                                        [ref] $fullPathReportPDFFile);
        } # if : Generate report with Default Compression Tool

        # 7Zip Compression Tool
        elseif ($compressionTool -eq '7')
        {
            # Generate a report using the 7Zip compression tool
            $result = $sevenZip.CreateNewReport($compiledBuildFullPath, `
                                                [ref] $fullPathReportTextFile, `
                                                [ref] $fullPathReportPDFFile);
        } # elseif : Generate report with 7Zip Compression Tool

        # Unknown Case
        else
        {
            # Unable to determine the selected compression tool

            # Alert the user that an error had been reached.
            [Notifications]::Notify([NotificationEventType]::Error);


            # Unknown condition was reached
            [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Error, "Unable to generate a report on the archive file!");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("An error had occur while attempting to generate a report on the archive data file!`r`n" + `
                                            "Please assure that you had specified if you want a report on the archive data file.");

            # Generate the initial message
            $logMessage = "Unable to generate a report of the archive data file due to an unknown or special rare event.";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Desired Compression Tool: $([string]$userPreferences.GetCompressionTool())`r`n" + `
                                "`tDefault Compression Generate Report Setting: $([string]$defaultCompress.GetGenerateReport())`r`n" + `
                                "`t7Zip Generate Report Setting: $([string]$sevenZip.GetGenerateReport())");


            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Because an error had been reached, we will have to abort the operation
            return $false;
        } # else : Unknown Case \ Error Case


        # Provide the user the locations as to where the report files are placed within the their system.
        #  Also revise the Nice Result such that we indicate that the report had been created successfully.
        if ($result)
        {
            # Because the reports were successfully generated, show where the files are located within their
            #  system.

            # Report File - Text Report
            # = - - - - - - - - - - - =
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, $fullPathReportTextFile);

            # Reveal the location using the user's preferred GUI Shell
            if ($userPreferences.GetUseWindowsExplorer())
            {
                # Access the desired directory and select the file.
                [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($fullPathReportTextFile), `
                                            [System.IO.Path]::GetFileName($fullPathReportTextFile));
            } # if : Reveal using the GUI Shell


            # Report File - PDF Report
            # = - - - - - - - - - - =
            if (($compressionTool -eq 'D' -and $defaultCompress.GetGenerateReportFilePDF()) -or `
                ($compressionTool -eq '7' -and $sevenZip.GetGenerateReportFilePDF()))
            {
                # User allowed the ability for PDF files to be generated
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, $fullPathReportPDFFile);

                # Reveal the location using the user's preferred GUI Shell
                if ($userPreferences.GetUseWindowsExplorer())
                {
                    # Access the desired directory and select the file.
                    [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($fullPathReportPDFFile), `
                                                [System.IO.Path]::GetFileName($fullPathReportPDFFile));
                } # if : Reveal using the GUI Shell
            } # if : Show PDF Report



            # Revise the status messages

            # We will show that the report was successfully created
            $resultNiceValue = "Successfully created the report!";

            # Revise the symbol such that we do not push an error symbol
            $resultSymbol = [FormattedListBuilder]::Child;
        } # if : Report Created Successfully

        # If the report could not be successfully generated.
        else
        {
            # Unable to generate report

            # Alert the user that the report could not be made.
            [Notifications]::Notify([NotificationEventType]::Warning);
        } # else : Failed to Generate Report



        # Show that the operation had been completed; provide its results
        [Builder]::DisplayBulletListMessage(1, $resultSymbol, $resultNiceValue);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully attempted to create a report based on the archive file!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Report based on the following archive file: $($compiledBuildFullPath)`r`n" + `
                            "`tNice Result Provided: $($resultNiceValue)`r`n" + `
                            "`tResult Given: $($result)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # Return the result back to the calling function
        return $result;
    } # GenerateReportArchiveDataFile()





   <# Generate Report: Project's Local Repository
    # -------------------------------
    # Documentation:
    #  This function will try to create a report regarding the
    #   local repository's current state and activity in relation
    #   to the project.  With the information gathered, the report
    #   will contain authors that had contributed, branches that
    #   are part of the project's development, and the activity
    #   within the present active branch.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to create the desired report
    #   $true  = Successfully created the requested report
    # -------------------------------
    #>
    hidden static [bool] GenerateReportProjectLocalRepository()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the Git Control object
        [GitControl] $gitControl = [GitControl]::GetInstance();

        # This will store the exit condition provided by the test function.
        [bool] $result = $false;

        # This is equivalent to the result [boolean] variable, but this will be displayed onto the
        #  terminal.  We will populate this value with a default value signifying that it had failed.
        #  However, we will update this value if the resulting operation was successful.
        [string] $resultNiceValue = "Failed to create a report on project's local repository!";

        # With this variable, we can adjust the symbol that is provided when issuing the bullet
        #  message to the user.  By default, we will use an error - but change it later if the
        #  operation was successful.
        [FormattedListBuilder] $resultSymbol = [FormattedListBuilder]::Failure;

        # When populated, these variables will hold the absolute paths of the generated report files.
        #  - Text Report File
        [string] $fullPathReportTextFile = $null;
        #  - PDF Report File
        [string] $fullPathReportPDFFile = $null;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Did the user wanted a report of the project's local repository?
        if (!$gitControl.GetGenerateReport())
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to generate a report on the project's local repository!";

            # Generate any additional information that might be useful
             $logAdditionalMSG = "Current Generate Report Setting: " + $([string]$gitControl.GetReportPath());

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *

            # Even though we did not perform the check, we will still return a successful signal to keep the process running.
            return $true;
        } # if : User Request; do not generate a report




        # Show that we are about to generate a report on the project's local repository.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Generating report of the project's local repository");
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "Report will be based on the " + [ProjectInformation]::projectName + " Local Repository.");
        [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, "Using project path: " + $userPreferences.GetProjectPath());


        # Let the user know that the report is being created
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Generating report. . .");


        # Generate the report
        if ($gitControl.CreateNewReport($userPreferences.GetProjectPath(), `
                                        [ref] $fullPathReportTextFile, `
                                        [ref] $fullPathReportPDFFile))
        {
            # Successfully generated the report; revise the variables so we can provide the results to the user.
            $resultNiceValue = "Successfully created the report!";
            $resultSymbol = [FormattedListBuilder]::Child;

            # Update the result, such that it provides a successful signal.
            $result = $true;


            # Because the reports were successfully generated, show where the files are located within their
            #  system.

            # Report File - Text Report
            # = - - - - - - - - - - - =
            [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, $fullPathReportTextFile);

            # Reveal the location using the user's preferred GUI Shell
            if ($userPreferences.GetUseWindowsExplorer())
            {
                # Access the desired directory and select the file.
                [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($fullPathReportTextFile), `
                                            [System.IO.Path]::GetFileName($fullPathReportTextFile));
            } # if : Reveal using the GUI Shell


            # Report File - PDF Report
            # = - - - - - - - - - - =
            if ($gitControl.GetGenerateReportFilePDF())
            {
                # User allowed the ability for PDF files to be generated
                [Builder]::DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, $fullPathReportPDFFile);

                # Reveal the location using the user's preferred GUI Shell
                if ($userPreferences.GetUseWindowsExplorer())
                {
                    # Access the desired directory and select the file.
                    [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($fullPathReportPDFFile), `
                                                [System.IO.Path]::GetFileName($fullPathReportPDFFile));
                } # if : Reveal using the GUI Shell
            } # if : Show PDF Report
        } # if : Report Created Successfully

        # If the report could not be successfully generated.
        else
        {
            # Unable to generate report

            # Alert the user that the report could not be made.
            [Notifications]::Notify([NotificationEventType]::Warning);
        } # else : Failed to Generate Report



        # Show that the operation had been completed; provide the results
        [Builder]::DisplayBulletListMessage(1, $resultSymbol, $resultNiceValue);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully attempted to create a report based on the project's local repository!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Report based on the following project path: $($userPreferences.GetProjectPath())`r`n" + `
                            "`tNice Result Provided: $($resultNiceValue)`r`n" + `
                            "`tResult Given: $($result)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # Return the result back to the calling function
        return $result;
    } # GenerateReportProjectLocalRepository()





   <# Show Project Location
    # -------------------------------
    # Documentation:
    #  This function will merely show where the project is located within the host's filesystem.
    # -------------------------------
    # Input:
    #  [string] Project Path
    #   The absolute path of the compiled project within the filesystem.
    # -------------------------------
    #>
    hidden static [void] ShowProjectLocation([string] $projectPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();
        # ----------------------------------------



        # Let the user know that we are about to show them the path to their newly generated compiled build.
        [Builder]::DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "You will find `"$([System.IO.Path]::GetFileName($projectPath))`" in this location:");

        # Show the path
        [Builder]::DisplayBulletListMessage(1, [FormattedListBuilder]::Child, $projectPath);


        # Reveal the project to the user using their preferred GUI Shell
        if ($userPreferences.GetUseWindowsExplorer())
        {
            [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($projectPath), `
                                        [System.IO.Path]::GetFileName($projectPath));
        } # if : Reveal using GUI Shell
    } # ShowProjectLocation()





   <# Display Bullet List Message
    # -------------------------------
    # Documentation:
    #  This function will act as a gateway into accessing the Formatted List.
    # -------------------------------
    # Input:
    #  [unsigned int] Message Position
    #   The position of the message that is to be displayed.  The position entails
    #       as to how many indentions are required before displaying the message.
    #  [FormattedListBuilder] Message Type
    #   The type of message that is to be presented to the user.  This usually could
    #   be a simple bullet list or provides a unique character for the message based
    #   on certain events.
    #  [string] Message String
    #   The message that will be displayed to the user.
    # -------------------------------
    #>
    hidden static [void] DisplayBulletListMessage([uint] $messagePosition, `            # How many indentions before message
                                                [FormattedListBuilder] $messageType, `  # Type of list or message
                                                [string] $messageString)                # Initial message to display
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This will hold the desired bullet point symbol or any special symbol
        #  that matches with the type of the message.
        [char] $bulletCharacter = $null;

        # Symbols that will be used when providing a list.
        [char] $symbolParent     = '>';     # Main Operation
        [char] $symbolChild      = '-';     # Sub-Main Operation
        [char] $symbolInProgress = '-';     # Task presently running
        [char] $symbolSuccessful = '-';     # Operation finished successfully
        [char] $symbolWarning    = '!';     # Reached a warning case
        [char] $symbolFailure    = '!';     # Operation reached an error
        # ----------------------------------------



        # Determine which symbol to use
        switch ($messageType)
        {
            # Parent
            ([FormattedListBuilder]::Parent)
            {
                # Use the Parent Symbol
                $bulletCharacter = $symbolParent;

                # Finished
                break;
            } # Parent


            # Child
            ([FormattedListBuilder]::Child)
            {
                # Use the Child Symbol
                $bulletCharacter = $symbolChild;

                # Finished
                break;
            } # Child


            # In-Progress
            ([FormattedListBuilder]::InProgress)
            {
                # Use the In-Progress Symbol
                $bulletCharacter = $symbolInProgress;

                # Finished
                break;
            } # In-Progress


            # Successful
            ([FormattedListBuilder]::Successful)
            {
                # Use the Successful Symbol
                $bulletCharacter = $symbolSuccessful;

                # Finished
                break;
            } # Successful


            # Warning
            ([FormattedListBuilder]::Warning)
            {
                # Use the Warning Symbol
                $bulletCharacter = $symbolWarning;

                # Finished
                break;
            } # Warning


            # Failure
            ([FormattedListBuilder]::Failure)
            {
                # Use the Failure Symbol
                $bulletCharacter = $symbolFailure;

                # Finished
                break;
            } # Failure


            # No Symbol
            default
            {
                # Do not use a symbol
                break;
            } # No Symbol
        } # Switch : Determine Symbol to Use



        # Provide the message
        [CommonCUI]::DrawFormattedList($messagePosition, `      # How many spaces to indent the message
                                        $bulletCharacter, `     # What symbol to use (optional)
                                        $messageString);        # Message to display
    } # DisplayBulletListMessage()
} # Builder




<# Builder Formatted List [ENUM]
 # -------------------------------
 # This will allow the ability to organize the type of messages that will be
 #  used within the Builder.
 # -------------------------------
 #>
 enum FormattedListBuilder
 {
     Parent         = 0; # Main Operation
     Child          = 1; # Sub-Operation
     InProgress     = 2; # Current Action
     Successful     = 3; # Operation was successful
     Warning        = 4; # A Warning had been raised
     Failure        = 5; # Operation had reached a failure
     NoSymbol       = 6; # No Symbol provided
 } # FormattedListBuilder
