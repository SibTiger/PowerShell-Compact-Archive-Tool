<# PowerShell Compact-Archive Tool
 # Copyright (C) 2025
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #>




<# Archive Zip
 # ------------------------------
 # ==============================
 # ==============================
 # This class will allow the user to compress one or more files into
 #  a single archive data file.  In order for this functionality to
 #  work we will use the built-in PowerShell Module to perform the
 #  desired operations.  As a benefit of using the built-in PowerShell
 #  Module, we do not need to worry about any external resources,
 #  everything is already available to utilize out-of-the-box.
 #
 #
 # PowerShell Module:
 #   - Microsoft.PowerShell.Archive (PowerShell Module)
 #     > https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.archive
 #>




class ArchiveZip
{
    # Member Variables :: Properties
    # =================================================
    # =================================================


    #region Hidden Variables

    # Log Root
    # ---------------
    # The absolute path to the parent directory.
    Hidden Static [string] $__rootLogPath = "$($global:_PROGRAMDATA_LOCAL_PROGRAM_LOGS_PATH_)\PSArchive";


    # Log Root Path
    # ---------------
    # The absolute path to the logs directory, where the Archive
    #   PowerShell Module activities will be stored.  Useful to
    #   capture errors and verbose activities when available.
    Hidden Static [string] $__logPath = "$([ArchiveZip]::__rootLogPath)\logs";

    #endregion



    # Member Functions :: Methods
    # =================================================
    # =================================================


    #region Hidden Functions

   <# Check Required Directories
    # -------------------------------
    # Documentation:
    #  This function will check to make sure that the log directories,
    #   that are used in this class, currently exists within the host's
    #   filesystem.
    #
    # ----
    #
    #  Directories to be checked:
    #   - %LOCALAPPDATA%\<PROG_NAME>\PSArchive
    #   - %LOCALAPPDATA%\<PROG_NAME>\PSArchive\logs
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #    $true  = Directories exist
    #    $false = One or more directories does not exist.
    # -------------------------------
    #>
    Hidden Static [bool] __CheckRequiredDirectories()
    {
        return (([CommonIO]::CheckPathExists([ArchiveZip]::__rootLogPath,   $true) -eq $true) -and `    # Check the Root Log Directory
                ([CommonIO]::CheckPathExists([ArchiveZip]::__logPath,       $true) -eq $true));         # Check the Log Path Directory
    } # __CheckRequiredDirectories()




   <# Create Directories
    # -------------------------------
    # Documentation:
    #  This function will create the necessary directories that will contain the log files
    #   that are generated from this class.  If the directories do not exist in the filesystem
    #   already, there is a chance that some operations might fail due to the inability to
    #   properly store the log files that are generated by the functions within this class.
    #  If the directories do not already exist, this function will try to create them
    #   automatically - without interacting with the end-user.
    #  If the directories already exist within the filesystem, then nothing will be performed.
    #
    # ----
    #
    #  Directories to be created:
    #   - %LOCALAPPDATA%\<PROG_NAME>\PSArchive
    #   - %LOCALAPPDATA%\<PROG_NAME>\PSArchive\logs
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #    $false = Failure creating the new directories.
    #    $true  = Successfully created the new directories
    #             OR
    #             Directories already existed, nothing to do.
    # -------------------------------
    #>
    Hidden static [bool] __CreateDirectories()
    {
        # First, check if the directories already exist.
        if([ArchiveZip]::__CheckRequiredDirectories())
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            [string] $logMessage = ("The Archive Zip logging directories already exists;" + `
                                    " there is no need to create the directories again.");

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("Archive Zip Logging Directories:`r`n" + `
                                        "`t`tThe Root Directory is:`t`t$([ArchiveZip]::__rootLogPath)`r`n" + `
                                        "`t`tThe Logging Directory is:`t$([ArchiveZip]::__logPath)`r`n");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *


            # The directories exist, no action is required.
            return $true;
        } # IF : Check if Directories Exists


        # ----


        # Because one or more of the directories does not exist, we must check
        #   which directory needs to be created.first

        # Root Log Directory
        if( ([CommonIO]::CheckPathExists([ArchiveZip]::__rootLogPath, $true) -eq $false) -and `     # Does the Root Log Directory Exists?
            ([CommonIO]::MakeDirectory([ArchiveZip]::__rootLogPath) -eq $false))                    # Try to Create the Root Log Directory...
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            [string] $logMessage = "Failed to create the Archive Zip root log directory!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("The root log directory path is:`r`n" + `
                                            "`t`t" + [ArchiveZip]::__rootLogPath);

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Failure occurred; could not create directory.
            return $false;
        } # If : Log Directory does not Exist && Log Directory Couldn't be Created


        # ----


        # Log Directory
        if( ([CommonIO]::CheckPathExists([ArchiveZip]::__logPath, $true) -eq $false) -and `     # Does the Log Directory Exists?
            ([CommonIO]::MakeDirectory([ArchiveZip]::__logPath) -eq $false))                    # Try to Create the Log Directory...
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            [string] $logMessage = "Failed to create the Archive Zip log directory!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("The log directory path is:`r`n" + `
                                            "`t`t" + [ArchiveZip]::__logPath);

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Failure occurred; could not create directory.
            return $false;
        } # If : Log Directory does not Exist && Log Directory Couldn't be Created


        # ----


        # The required directories are now available.
        return $true;
    } # __CreateDirectories()

    #endregion



    #region Visible Functions


   <# Detect Compression Module
    # -------------------------------
    # Documentation:
    #  This function will detect if the required PowerShell Module(s),
    #   are available within the current PowerShell's environment.
    #
    # DEVELOPER NOTE:
    #   Using 'Get-Module' CMDLet will return $true if there is any version installed
    #   of the desired PowerShell Module.  Otherwise, $false will be given.
    #   Reference: https://stackoverflow.com/a/28740512
    # -------------------------------
    # Output:
    #  [bool] Detection State
    #   $true   = Required PowerShell Module was found
    #   $false  = Required PowerShell Module was not found
    # -------------------------------
    #>
    Static [bool] DetectCompressModule()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # The PowerShell Module name for the Archive functionality that we use within this class.
        [string] $moduleName = "Microsoft.PowerShell.Archive";
        # ----------------------------------------



        # Determine if /any/ version of the PowerShell Module was found
        #   within the current PowerShell environment.
        if (Get-Module -ListAvailable -Name $moduleName)
        {
            # Detected the PowerShell Module


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            [string] $logMessage = "Found the PowerShell Module: " + $moduleName + "!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = "It is possible to use $($moduleName) features!";

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Return that we had found the PowerShell Module
            return $true;
        } # if : Module is installed



        # Unable to find the required PowerShell Module


        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate a message to display to the user.
        [string] $displayErrorMessage = ("It is not possible to create a compressed file, because the required PowerShell " + `
                                            "Modules were not found:`r`n " + `
                                        "`t" + $moduleName + "`r`n" + `
                                        "`r`n" + `
                                        "Please make sure that you have the latest version of the PowerShell Core installed:`r`n" + `
                                        "`thttps://github.com/PowerShell/PowerShell");

        # Generate the initial message
        [string] $logMessage = "Could not find the PowerShell Module: " + $moduleName + "!";

        # Generate any additional information that might be useful
        [string] $logAdditionalMSG = ("It is not possible to use $($moduleName) features!`r`n" + `
                                    "`tPlease make sure that you have the latest version of the PowerShell Core installed:`r`n" + `
                                    "`t`thttps://github.com/PowerShell/PowerShell");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Error);      # Message level

        # Display a message to the user that something went horribly wrong
        #  and log that same message for referencing purpose.
        [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                    [LogMessageLevel]::Error);  # Message level

        # Alert the user through a message box as well that an issue had occurred;
        #   the message will be brief as the full details remain within the terminal.
        [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;
        # * * * * * * * * * * * * * * * * * * *


        # Return that we could not find the PowerShell Module
        return $false;
    } # DetectCompressModule()




   <# Create Archive File
    # -------------------------------
    # Documentation:
    #  This function will create a new compress file by compacting files that were found
    #   within the target directory.  This function is designed to perform bulk compression,
    #   meaning that the files must exist within the directory - and be readable - in order
    #   to be included into the archive datafile.  It is not, however, possible to explicitly
    #   define what files are to be included into a compress file.
    #
    #
    # DEVELOPER NOTE:
    #  We will use the Compress-Archive CMDLet, coming from the PowerShell Module:
    #   Microsoft.PowerShell.Archive.
    #
    #  Compress-Archive Information:
    #    https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.archive/compress-archive
    # -------------------------------
    # Input:
    #  [string] Archive File Name Request
    #   The name of the Compressed File that will be created.
    #       NOTE: If the filename already exists, then a Date and Time stamp will be included at
    #               the end of the filename only to make it unique.
    #  [string] Output Path
    #   The location of where the compressed file will be stored.
    #  [string] Target Directory
    #   The location of the directory's contents that we want to compact into a compressed file.
    #       NOTE: This argument supports the use of wildcards.
    #               For example:
    #                   D:\Users\Admin\Desktop\TopSecret\*.*
    #  [string] (REFERENCE) Archive Path
    #   This string will provide the absolute full path (including the filename + extension) to
    #   the archive datafile.  This string is returned back to the calling function.
    # -------------------------------
    # Output:
    #  [bool] Status Code
    #    $true  = Successfully created the compressed file.
    #    $false = Failed to create the compressed file.
    # -------------------------------
    #>
    Static [bool] CreateArchive([string] $archiveFileNameRequest, `     # The name of the compressed file
                                [string] $outputPath, `                 # The destination path for the compressed file
                                [string] $targetDirectory, `            # The directory contents we want to compact
                                [ref] $archivePath)                     # The full path of the compressed file (including filename + extension)
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string] $archiveFileExtension = "pk3";                         # This will hold the archive file's extension.
        [string] $archiveFileName = `                                   # This will hold the archive data file's full name, including the
                "$($outputPath)\$($archiveFileNameRequest)";            #  absolute path to access the file specifically.
        [string] $compressionLevel = "Optimal";                         # Specified Compression Level to be used when creating the compressed
                                                                        #   file.
        [bool] $exitCode = $false;                                      # The exit code status provided by the Compress-Archive operation
                                                                        #  status.  If the operation was successful, then true will be
                                                                        #  set.  Otherwise, it well be set as false to signify an error.
        [string] $execReason = "Creating " + $archiveFileNameRequest;   # Description; used for logging
        [System.Object] $execSTDOUT = [System.Object]::new();           # This will hold the STDOUT that is provided by the CMDLet that
                                                                        #  will be used for compacting the archive file, but contained
                                                                        #  as an object.
        [System.Object] $execSTDERR = [System.Object]::new();           # This will hold the STDERR that is provided by the CMDLet that
                                                                        #  will be used for compacting the archive file, but contained
                                                                        #  as an object.
        [System.Object] $execSTDERR = [System.Object]::new();           # This will hold the STDERR that is provided by the CMDLet that
                                                                        #  will be used for compacting the archive file, but contained
                                                                        #  as an object.
        [string] $strSTDOUT = $null;                                    # This will hold the STDOUT information, but will be held as a
                                                                        #  literal string.  The information provided to it will be
                                                                        #  converted from an object to a string, the information held
                                                                        #  in this variable will be presented in the logfile.
        [string] $strSTDERR = $null;                                    # This will hold the STDERR information, but will be held as a
                                                                        #  literal string.  The information provided to it will be
                                                                        #  converted from an object to a string, the information held
                                                                        #  in this variable will be presented in the logfile.
        # ----------------------------------------



        # Dependency Check
        # - - - - - - - - - - - - - -
        #  Make sure that all of the resources are available before trying to use them
        #   This check is to make sure that nothing goes horribly wrong.
        # ---------------------------

        # Make sure that the logging requirements are met.
        if ([ArchiveZip]::__CreateDirectories() -eq $false)
        {
            # Because the logging directories could not be created, we cannot log.


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("Unable to create a new compress file:`r`n " + `
                                            "`t" + $archiveFileNameRequest + "`r`n" + `
                                            "The Log directories could not be created!`r`n" + `
                                            "Please make sure that your have sufficient privileges to create directories in:`r`n" + `
                                            "`t" + $global:_PROGRAMDATA_LOCAL_PROGRAM_LOGS_PATH_);

            # Generate the initial message
            [string] $logMessage = "Unable to create a new compressed file because the log directories could not be created!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("Because the log directories for the Archive Zip could not be created, " + `
                                            "nothing can be logged as required.`r`n" + `
                                        "`tTried to create directories in:`r`n" + `
                                        "`t`t" + $global:_PROGRAMDATA_LOCAL_PROGRAM_LOGS_PATH_ + "`r`n" + `
                                        "`tTo resolve the issue:`r`n" + `
                                        "`t`t- Make sure that the required log directories are created.`r`n" + `
                                        "`t`t- Make sure that you have sufficient permissions to create directories.`r`n" + `
                                        "`tTried to create Compress File:`r`n" + `
                                        "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                        "`tPath of the contents to compact:`r`n" + `
                                        "`t`t" + $targetDirectory);

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Because the logging features are required, we cannot run the operation.
            return $false;
        } # If : Logging Requirements are Met


        # Make sure that the current PowerShell instance has the proper PowerShell Module ready.
        if ([ArchiveZip]::DetectCompressModule() -eq $false)
        {
            # Because this current PowerShell instance lacks the functionality required to create the
            #  archive datafile, we cannot proceed any further.


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("Unable to create a new compressed file:`r`n" + `
                                            "`t" + $archiveFileNameRequest + "`r`n" + `
                                            "Because the PowerShell Module was not found, it is not possible " + `
                                                "to create a new compress file!");

            # Generate the initial message
            [string] $logMessage = "Unable to create a new compress file because the required PowerShell Module was not found!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("Tried to create the Compress File:`r`n" + `
                                        "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                        "`tPath of the contents to compact:`r`n" + `
                                        "`t`t" + $targetDirectory);

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Because the required module was not found, we cannot proceed any further.
            return $false;
        } # if : PowerShell Archive Support Missing


        # Make sure that the desired output path currently exists
        if ([CommonIO]::CheckPathExists($outputPath, $true) -eq $false)
        {
            # The requested output path does not currently exist; we cannot proceed any further.


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("Unable to create a new compress file:`r`n" + `
                                            "`t" + $archiveFileNameRequest + "`r`n" + `
                                            "The path to store the compressed file is not correct!`r`n" + `
                                            "The path given to output the compressed file:`r`n" + `
                                            "`t" + $outputPath);

            # Generate the initial message
            [string] $logMessage = "Unable to create a new compress file because the output directory does not exist!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("The Archive Data File to Create:`r`n" + `
                                            "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                            "`tOutput Path to Place the Compressed File:`r`n" + `
                                            "`t`t" + $outputPath);

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # The output path does not exist; we cannot create archive file.
            return $false;
        } # if : Output Directory does not exist


        # Check to make sure that the target path directory or file(s) already exists within the filesystem.
        if ([CommonIO]::CheckPathExists($targetDirectory, $false) -eq $false)
        {
            # The target directory does not exist; we cannot compact the requested data as the target directory
            #  does not exist with the given path.


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("Unable to create a new compress file:`r`n" + `
                                            "`t" + $archiveFileNameRequest + "`r`n" + `
                                            "The path to the files that are to be compressed is not correct.`r`n" + `
                                            "The path to the files to compress given is:`r`n" + `
                                            "`t" + $targetDirectory);

            # Generate the initial message
            [string] $logMessage = "Unable to create a new compress file because the target directory path does not exist!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("The Archive Data File to Create:`r`n" + `
                                            "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                            "`tTarget Directory Path to Compress:`t`n" + `
                                            "`t`t" + $targetDirectory);

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Return a failure as the target directory does not exist.
            return $false;
        } # if : Target Directory does not Exist

        # ---------------------------
        # - - - - - - - - - - - - - -



        # DETERMINE ARCHIVE FILE NAME
        # - - - - - - - - - - - - - -
        # We will need to determine a unique file name of the archive data file.  If the original name given is not sufficient,
        #  if some other file has the same name in the output directory, then we will merely apply a timestamp to help make it unique.
        # ---------------------------


        # If the filename is not unique, try to make it unique.
        if ([CommonIO]::CheckPathExists("$($archiveFileName).$($archiveFileExtension)", $true) -eq $true)
        {
            # Because the filename already exists within the given output path, we can make it unique by adding in a timestamp
            #  to the filename.  However, if in case we cannot make the filename unique (even with the timestamp), then the
            #  operation must be aborted.


            # Setup the timestamp to help make it unique.
            #  Formatting of the Date and Time:
            #  DD-MMM-YYYY_HH-MM-SS ~~> 09-Feb-2007_01-00-00
            [string] $getDateTime = [string](Get-Date -UFormat "%d-%b-%Y_%H-%M-%S");

            # Update the archive filename to include the date and time stamp.
            $archiveFileName = "$($archiveFileName)_$($getDateTime)";

            # Check to make sure that the new filename is unique, if not - then we cannot proceed.
            if ([CommonIO]::CheckPathExists("$($archiveFileName).$($archiveFileExtension)", $true) -eq $true)
            {
                # Because the archive file name is still not unique enough, we cannot proceed anymore.
                #  This function will have to be aborted.


                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Prep a message to display to the user for this error; temporary variable.
                [string] $displayErrorMessage = ("Unable to create a new compress file:`r`n" + `
                                                "`t" + $archiveFileNameRequest + "`r`n" + `
                                                "It was not possible to create a unique filename for the compress file.`r`n" + `
                                                "The path given to output the compressed file:`r`n" + `
                                                "`t" + $outputPath + "`r`n" + `
                                                "Tried to use the filename instead:`r`n" + `
                                                "`t$($archiveFileName).$($archiveFileExtension)");

                # Generate the initial message
                [string] $logMessage = "Unable to create a new compress file because the filename could not be unique!";

                # Generate any additional information that might be useful
                [string] $logAdditionalMSG = ("The Archive Data File to Create:`r`n" + `
                                            "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                            "`tOutput Path to Place the Compressed File:`r`n" + `
                                            "`t`t" + $outputPath + "`r`n" + `
                                            "`tCompress File Full Output Path:`r`n" + `
                                            "`t`t$($archiveFileName).$($archiveFileExtension)");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                            $logAdditionalMSG, `        # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # Alert the user through a message box as well that an issue had occurred;
                #   the message will be brief as the full details remain within the terminal.
                [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

                # * * * * * * * * * * * * * * * * * * *


                # Return an error.
                return $false;
            } # INNER-IF: Unable to make it unique
        } # If: File Already Exists at Path


        # Now save the output path to our reference (pointer) variable, this will allow the calling function to get the absolute path of
        #  where the archive file resides.
        $archivePath.Value = "$($archiveFileName).$($archiveFileExtension)";


        # ---------------------------
        # - - - - - - - - - - - - - -



        # CREATE ARCHIVE DATAFILE
        # - - - - - - - - - - - - - - -
        # -----------------------------

        # Execute the Compress-Archive CMDLet
        try
        {
            # Create the archive datafile.
            Compress-Archive -Path "$($targetDirectory)\*" `
                             -DestinationPath "$($archiveFileName).$($archiveFileExtension)" `
                             -CompressionLevel $compressionLevel `
                             -ErrorAction Stop `
                             -PassThru `
                             -OutVariable execSTDOUT `
                             -ErrorVariable execSTDERR;

            # Update the Exit Code status; the operation was successful.
            $exitCode = $true;
        } # try : Execute Compression Task

        # An error occurred; the data is too large to compact
        catch [System.OutOfMemoryException]
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Prep a message to display to the user for this error; temporary variable
            [string] $displayErrorMessage = ("Failed to create the compressed file because there was not enough system memory!`r`n" + `
                                            [Logging]::GetExceptionInfoShort($_.Exception));

            # Generate the initial message
            [string] $logMessage = "Failed to create the archive datafile due to memory constraints!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("The Archive Data File to Create:`r`n" + `
                                            "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                            "`tThe contents to compact:`r`n" + `
                                            "`t`t" + $targetDirectory + "`r`n" + `
                                            "`tOutput Path to place the Compressed File:`r`n" + `
                                            "`t`t" + $outputPath + "`r`n" + `
                                            "`tThe full path to the archive data file:`r`n" + `
                                            "`t`t" + $archiveFileName + "." + $archiveFileExtension + "`r`n" + `
                                            [Logging]::GetExceptionInfo($_.Exception));

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *
        } # Catch [OutOfMemory] : File(s) too large

        # A general error had occurred
        catch
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Prep a message to display to the user for this error; temporary variable
            [string] $displayErrorMessage = ("Failed to create the compressed file!`r`n" + `
                                            "$([Logging]::GetExceptionInfoShort($_.Exception))");

            # Generate the initial message
            [string] $logMessage = "Failed to create the archive datafile due to a hard error!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("The Archive Data File to Create:`r`n" + `
                                            "`t`t" + $archiveFileNameRequest + "`r`n" + `
                                            "`tThe contents to compact:`r`n" + `
                                            "`t`t" + $targetDirectory + "`r`n" + `
                                            "`tOutput Path to place the Compressed File:`r`n" + `
                                            "`t`t" + $outputPath + "`r`n" + `
                                            "`tThe full path to the archive data file:`r`n" + `
                                            "`t`t" + $archiveFileName + "." + $archiveFileExtension + "`r`n" + `
                                            [Logging]::GetExceptionInfo($_.Exception));

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *
        } # catch : Caught Error in Compression Task

        # Log the activity in the logfiles (if requested)
        finally
        {
            # If the STDOUT contains the file path of the archive datafile,
            #  then we will store it for logging purposes.
            if (![CommonIO]::IsStringEmpty($execSTDOUT))
            {
                # Because we only created just one compressed datafile, we
                #  will only have one output file - not multiple.  With that,
                #  we just need to capture just the one output file - which is
                #  our compressed archive datafile.
                $strSTDOUT = "Newly created archive datafile path: " + [string]($execSTDOUT);
            } # if : STDOUT Is not null



            # If the STDERR contains information, then store
            #  it as a standard string datatype.  Luckily the
            #  information provided within the object requires
            #  no real changes or data manipulation, we can
            #  just cast it and it works like magic!  I love
            #  the simplicity!
            if ($null -ne $execSTDERR)
            {
                # No need to filter or manipulate the data, just
                #  cast it as is.  Everything we need is already
                #  available and readable.
                $strSTDERR = [string]($execSTDERR);
            } # if : STDERR Is not null


            # Create the logfiles
            [CommonIO]::PSCMDLetLogging([ArchiveZip]::__logPath, `
                                        [ArchiveZip]::__logPath, `
                                        $NULL, `
                                        $false, `
                                        $false, `
                                        $execReason, `
                                        $null, `
                                        [ref] $strSTDOUT, `
                                        [ref] $strSTDERR );
        } # finally : Log the activity in the log files



        # -----------------------------
        # - - - - - - - - - - - - - - -


        # Finished with the operation
        return $exitCode;
    } # CreateArchive()




   <# Delete Logs
    # -------------------------------
    # Documentation:
    #  This function will delete all log files that had been generated by this class.  The log files
    #   that had been created by this class will be stored within the Log Path as defined within the
    #   Class static variables.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $true   = Successfully Deleted the log files.
    #   $false  = One or more operations failed.
    # -------------------------------
    #>
    Static [bool] DeleteLogs()
    {
        # Declarations and Initializations
        # ----------------------------------------
        [string[]] $filesToDelete = @('*.*');       # Array of files to delete
        # ----------------------------------------


        # Make sure that the logging directories exist.  If the directories are not
        #  available presently, than there is nothing that can be done at this time.
        if ([ArchiveZip]::__CheckRequiredDirectories() -eq $false)
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            [string] $logMessage = "Unable to delete the log files as the logging directories for Archive Zip were not found!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("Class: ArchiveZip`r`n" + `
                                        "`tArchive Zip Logging Directories:`r`n" + `
                                        "`t`tThe Root Directory is:`t`t$([ArchiveZip]::__rootLogPath)`r`n" + `
                                        "`t`tThe Logging Directory is:`t$([ArchiveZip]::__logPath)`r`n");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Warning);    # Message level

            # * * * * * * * * * * * * * * * * * * *



            # This is not really an error, however the directories simply does not exist.
            #  Nothing can be done.
            return $true;
        } # IF : Required Directories Exists


        # Because the directories exists - let's try to delete the logs.
        if([CommonIO]::DeleteFile([ArchiveZip]::__logPath, $filesToDelete, $false) -eq $false)
        {
            # Reached a failure upon removing the requested log files.


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            [string] $logMessage = "A failure occurred while removing the Archive Zip log files!";

            # Generate any additional information that might be useful
            [string] $logAdditionalMSG = ("Class: ArchiveZip`r`n" + `
                                        "`tArchive Zip Logging Directories:`r`n" + `
                                        "`t`tThe Root Directory is:`t`t$([ArchiveZip]::__rootLogPath)`r`n" + `
                                        "`t`tThe Logging Directory is:`t$([ArchiveZip]::__logPath)`r`n");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # * * * * * * * * * * * * * * * * * * *


            # Signify that an error had occurred.
            return $false;
        } # If : failure to delete files



        # The operation was successful


        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        [string] $logMessage = "Successfully deleted the ArchiveZip log files!";

        # Generate any additional information that might be useful
        [string] $logAdditionalMSG = ("Class: ArchiveZip`r`n" + `
                                    "`tArchive Zip Logging Directories:`r`n" + `
                                    "`t`tThe Root Directory is:`t`t$([ArchiveZip]::__rootLogPath)`r`n" + `
                                    "`t`tThe Logging Directory is:`t$([ArchiveZip]::__logPath)`r`n");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # Operation was successful
        return $true;
    } # DeleteLogs()

    #endregion
} # ArchiveZip