<# PowerShell Compact-Archive Tool
 # Copyright (C) 2023
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #>




<# Builder
 # ------------------------------
 # ==============================
 # ==============================
 # This class provides the ability to compile the project's assets into a single archive data file.
 #  This builder, has the ability to perform various tasks, such as:
 #      - Updating the project's resources to the latest revision based on the Remote Repository.
 #      - Assure the necessary dependencies are available and active.
 #      - Validate the integrity of the newly compiled build.
 #      - Generate any documentation as requested.
 #>



class Builder
{
   <# Build
    # -------------------------------
    # Documentation:
    #  This function is essentially our main driver into creating a
    #   ZDoom based archive datafile generated by using the project's
    #   source files.  Because this function is our main driver into
    #   achieving this goal, we have to assure that the process is
    #   well organized and is keeping the operation - easy to manage.
    #   By doing this, we will want to approach this in a sequential
    #   manner while also checking our work consistently.  Meaning,
    #   in order to compile the project's source files into one single
    #   archive file, we may need to update the source via a Source
    #   Control tool - then we may proceed with compacting the data.
    #   This is only a brief example out of many possible cases now
    #   and as well in the future when and if the functionality were
    #   to expand.
    # -------------------------------
    # Input:
    #  [bool] Make Development Build
    #   When this flag is true, this will allow the ability create
    #   a developmental build of the project.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = The Project Build had reached an error.
    #   $true = The Project Build had successfully been created.
    # -------------------------------
    #>
    static [bool] Build()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the Project Information object; this contains details
        #  in regards to where the source files exists within the user's system.
        [ProjectInformation] $projectInformation = [ProjectInformation]::GetInstance();

        # Archive datafile's final destination path
        [string] $compiledBuildPath = $null;

        # The file name for the archive datafile.
        [string] $fileName = $null;

        # The Temporary Directory path that will hold the
        #  project's contents.
        [string] $projectTemporaryPath = $null;
        # ----------------------------------------


        # Clear the terminal of all previous text; keep the space clean so that
        #  it is easy for the user to read and follow along.
        [CommonIO]::ClearBuffer();


        # Draw Program Information Header
        [CommonCUI]::DrawProgramTitleHeader();


        # Show the user that they are at the Main Menu
        [CommonCUI]::DrawSectionHeader("Compiling the $($projectInformation.GetProjectName()) [$($projectInformation.GetCodeName())] Project");


        # Display the instructions
        [CommonCUI]::CompileInstructions();





        #           Prerequisite Check
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Make sure that we have all of the resources that we are going to
        #  need in order to successfully compile this project.
        if (![Builder]::__PrerequisiteCheck())
        {
            # Because we are lacking a required resource, we cannot proceed with
            #  this process.
            return $false;
        } # if : Evaluate Prerequisite Check


        # Because we have all of the resources that we need - in order to compile
        #  this project, we can proceed to the next step!





        #        Generate Output Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *
        # Determine and generate the output directory in which this compiled
        #  build will be stored.

        $compiledBuildPath = [Builder]::__GenerateOutputPath();





        #            Generate Filename
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # We will need to know the file name that will identify archive datafile,
        #  as well as the file extension that will help to classify the archive
        #  datafile's data structure.
        $fileName = [Builder]::__GenerateArchiveFileName();





        #         Create Temporary Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to create a new temporary directory, such that we may manipulate or
        #  alter the files if necessary - without having to change the state or
        #  lose files within the user's local copy of the project.
        if (![Builder]::__CreateProjectTemporaryDirectory([ref] $projectTemporaryPath))
        {
            # Because there was an error while to create a new unique temporary directory,
            #  we cannot proceed forward with this operation.  Thus, we will have to abort
            #  the procedure.
            return $false;
        } # if : Cannot Create Temporary Directory





        #         Mirror Project Files
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Duplicate the project's source files to the temporary directory location.
        if (![Builder]::__DuplicateSourceToTemporaryDirectory($projectTemporaryPath))
        {
            # Because we were unable to duplicate the files, we are unable to proceed
            #  with the operation.
            return $false;
        } # if: Cannot Duplicate Source Files





        #        Thrash Superfluous Assets
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Discard any extraneous assets from the temporary directory.
        #  We are not interested in any fluff, as that can enlarge the final compile build.
        if (![Builder]::__ExpungeExtraneousResources($projectTemporaryPath))
        {
            # Because we could not delete the superfluous assets, we could not continue this
            #  operation.  Now, with that, it could be possible to continue the operation as
            #  normal - having the extra assets that is unrelated to the game files or project
            #  in itself is not such a big deal, HOWEVER, it could be an issue if there are
            #  sensitive information that is not meant to be visible to other users -
            #  regardless where or what.

            # Thus, if we cannot expunge any of the superfluous data, then return an error
            #  signal.
            return $false;
        } # Could not Delete Superfluous Files





        #             Compile Project
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to compact the project files into an archive datafile.
        if (![Builder]::__CompileProject($fileName, `               # Archive filename
                                        [ref]$compiledBuildPath, `  # Archive file location (output file)
                                        $projectTemporaryPath))     # Project's absolute path
        {
            # Because there was an error while compiling the project's source
            #  files, we will have to abort at this point.
            return $false;
        } # if : Compile Project





        #         Delete Temporary Directory
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to delete the temporary directory that was previously created, as
        #  we no longer require that resource anymore for this operation.
        if (![Builder]::__DeleteProjectTemporaryDirectory($projectTemporaryPath))
        {
            # Because there was an error while trying to delete the temporary directory,
            #  we will land in this condition, but we may proceed onward regardless.
            # The Operating System may try to remove the directory in a later date by
            #  default.
            ;
        } # if : Cannot Create Temporary Directory





        #               Test Build
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to test the archive data file to assure that it is not damaged.
        if (![Builder]::__TestCompiledBuild($compiledBuildPath))
        {
            # Because the archive datafile is damaged or corrupted, we will have
            #  to abort the operation as we reached an error.
            return $false;
        } # if : Test Compiled Build





        #            Generate Reports
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Try to generate report based on the archive data file.
        if (![Builder]::__GenerateReportArchiveDataFile($compiledBuildPath))
        {
            # Because we could not generate a report of the archive data file, the
            #  file might had been damaged or is corrupted.
            return $false;
        } # if : Generate Report Failed for Archive File





        #          Show Project Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Now that we are finished, show the user where their compiled build
        #  is within the host's filesystem.
        [Builder]::__ShowProjectLocation($compiledBuildPath);





        # Alert the user that the operation had finished
        [NotificationAudible]::Notify([NotificationAudibleEventType]::Success);
        [NotificationVisual]::Notify("Successfully compiled $($projectInformation.GetProjectName())!");


        # Show that the compiling operation was successful.
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Operation had been completed!");


        # Operation was successful!
        return $true;
    } # Build()




   <# Prerequisite Check
    # -------------------------------
    # Documentation:
    #  This function performs a validation check to assure that all
    #   of the required resources are available for the compiling
    #   process.  If incase we found one or more resources - that
    #   is imperative for the entire operation to work correctly -
    #   then we may ultimately abruptly abort the entire compile
    #   operation.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = One or more resources were missing but required.
    #   $true = All of the resources were accounted for and ready.
    # -------------------------------
    #>
    hidden static [bool] __PrerequisiteCheck()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the Project Information object; this contains details
        #  in regards to where the source files exists within the user's system.
        [ProjectInformation] $projectInformation = [ProjectInformation]::GetInstance();

        # Latch onto the single instance of the Zip object
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();

        # We will use this variable to cache the detection status of a particular item that we want
        #  to check.  Instead of having to recall the exact same checking function over and over again,
        #  we will use this variable to merely cache the value as we step through each process within
        #  the checking procedure.
        [bool] $boolCacheValue = $false;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # Show that the Prerequisite functionality is presently active
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Prerequisite Check");
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Performing a Prerequisite Check. . .");



        #              Project Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Project Path
        $boolCacheValue = [CommonIO]::CheckPathExists($projectInformation.GetProjectPath(), $true);

        # Can we find the project's source files?
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the project's source files; unable to continue.

            # Alert the user that an error had been reached.
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


            # Show that the Project's source files could not be found.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find $($projectInformation.GetProjectName()) source files!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the program settings!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I am unable to find the $($projectInformation.GetProjectName()) source files!`r`n" + `
                                            "Please reconfigure the path for the $($projectInformation.GetProjectName()) project!`r`n" + `
                                            "`t- $($projectInformation.GetProjectName()) Project Path is presently: $($projectInformation.GetProjectPath())`r`n" + `
                                            "`t- Path Exists Detection Status: $([string]$boolCacheValue)");

            # Generate the initial message
            $logMessage = "Unable to find the $($projectInformation.GetProjectName()) project's source files!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please reconfigure the location of the $($projectInformation.GetProjectName()) Project's Source.`r`n" + `
                                "`tProject Source Location is: $($projectInformation.GetProjectPath())`r`n" + `
                                "`tProject Source Path Exists: $([string]$boolCacheValue)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the project's source files, we have to abort the operation.
            return $false;
        } # if : Check Project source files exists



        # Successfully found project files
        [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the $($projectInformation.GetProjectName()) source files!");




        #              Output Path
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Output Path
        $boolCacheValue = [CommonIO]::CheckPathExists($userPreferences.GetProjectBuildsPath(), $true);

        # Can we find the output path?
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the output path directory; unable to continue.

            # Alert the user that an error had been reached.
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


            # Show that the Output Directory could not be found.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find the Output Directory!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please reconfigure the Program's Generalized Settings!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I cannot find the folder to store any new compiled builds!`r`n" + `
                                            "Please reconfigure the Output Path in the program's general settings!`r`n" + `
                                            "`t- Output Path is presently: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                            "`t- Path Exists Detection Status: $([string]$boolCacheValue)");

            # Generate the initial message
            $logMessage = "Unable to find the Output Directory!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please reconfigure the location of the Output Directory.`r`n" + `
                                "`tOutput Directory Location is: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                "`tOutput Directory Path Found: $([string]$boolCacheValue)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `   # Message to display
                                    [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the output directory, we have no place to place the
            #  compiled build.  We cannot continue this operation.
            return $false;
        } # if : Check Output Path exists



        # Successfully found output directory
        [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Successful, "Found the Output Directory!");




        #            Compression Tool
        # * * * * * * * * * * * * * * * * * * * *
        # * * * * * * * * * * * * * * * * * * * *

        # Check the current status of the Archive ZIP Module
        $boolCacheValue = $defaultCompress.DetectCompressModule();

        # Make sure that the dotNET Archive Zip is available
        if ($boolCacheValue -eq $false)
        {
            # Unable to find the dotNET Archive Zip

            # Alert the user that an error had been reached.
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


            # Show that this program cannot detect the dotNET Core Archive ZIP functionality.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to find native support with Default ZIP functionality");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please assure that you are using the latest version of PowerShell Core!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I am unable to find support for ZIP in this version of PowerShell!`r`n" + `
                                            "Please make sure that you are using the latest version of PowerShell Core!`r`n" + `
                                            "`t- You are currently using PowerShell Core Version: $([SystemInformation]::PowerShellVersion())`r`n" + `
                                            "`t- ZIP Archive Module Detection Status: $([string]$boolCacheValue)`r`n" + `
                                            "`t- You may check out any new releases of the PowerShell Core at GitHub!`r`n" + `
                                            "`t`thttps://github.com/PowerShell/PowerShell/releases");

            # Generate the initial message
            $logMessage = "Unable to find the dotNET Archive Zip Module!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please assure that you are currently using the latest version of PowerShell Core!`r`n" + `
                                "`tArchive ZIP Module Detection reported: $([string]$boolCacheValue)`r`n" + `
                                "`tPowerShell Version: $([SystemInformation]::PowerShellVersion())`r`n" + `
                                "`tOperating System: $([String][SystemInformation]::OperatingSystem())`r`n" + `
                                "`tCheck for new versions of PowerShell Core at the provided official website:`r`n" + `
                                "`t`thttps://github.com/PowerShell/PowerShell/releases");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Because we cannot find the default internal Archive Module within PowerShell, we
            #  cannot proceed forward with the compiling phase.
            return $false;
        } # if : Check if dotNET Archive Zip Exists



        # Show that the Perquisite Check had passed!
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully found all the required resources!");




        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = ("The Prerequisite Check had determined that we have all of the required" + `
                        "resources necessary to compile the $($projectInformation.GetProjectName()) project!");

        # Generate any additional information that might be useful
        $logAdditionalMSG = "Prerequisite Check had successfully passed!";

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # If we made it to this point, then we have all of the resources
        #  that we need to compile this project!
        return $true;
    } # __PrerequisiteCheck()





   <# Generate Archive Filename
    # -------------------------------
    # Documentation:
    #  This function will allow the ability to automatically generate
    #   the archive filename.
    # -------------------------------
    # Input:
    #   [void] None
    # -------------------------------
    # Output:
    #   [string] Archive Datafile Name
    #       The name of the archive datafile that will be generated.
    # -------------------------------
    #>
    hidden static [string] __GenerateArchiveFileName()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This will hold the filename for the archive data file
        [string] $archiveFileName = $null;

        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the Project Information object; this contains details
        #  in regards to where the source files exists within the user's system.
        [ProjectInformation] $projectInformation = [ProjectInformation]::GetInstance();
        # ----------------------------------------



        # Show that we gathering filename information
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Gathering filename information. . .");



        # Apply the core filename of the archive datafile
        $archiveFileName = $projectInformation.GetFileName();



        # Show the filename that has been generated.
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully generated the filename!");
        [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "File Name is `"$($archiveFileName)`".");



        # Return the full archive data file
        return $archiveFileName;
    } # __GenerateArchiveFileName()






   <# Generate Output Path
    # -------------------------------
    # Documentation:
    #  This function will determine the final location as to where the compiled build will be
    #   located in the user's systems.  This will assure that development builds and production
    #   builds are not combined and mixed into one directory.  As such, this will help to keep
    #   the builds organized and prevent some human errors when trying to look for a particular
    #   build or version.
    # -------------------------------
    #>
    hidden static [string] __GenerateOutputPath()
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();
        # ----------------------------------------


        # Show that we determining the final output location
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Determining the Output Directory. . .");


        # Show that we had concluded the output directory and everything is finished!
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "The compiled build will be stored under `"$($userPreferences.GetProjectBuildsPath())`"");


        # We will store the archive file in the output directory as-is
        return $userPreferences.GetProjectBuildsPath();
    } # __GenerateOutputPath()






   <# Compile Project
    # -------------------------------
    # Documentation:
    #  This function will try to compile the project's files into
    #   one archive datafile.  This will make it possible to easily
    #   distribute the project files to other users as well as
    #   make it available onto servers.
    # -------------------------------
    # Input:
    #  [string] Archive File Name
    #   The requested name of the archive data file that is going to be created.
    #  [string] (REFERENCE) File Path
    #   The final absolute path of the archive datafile.
    #  [string] Project Directory
    #   This provides the location of where the project files are located, this
    #   is usually in a unique temporary directory.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Unable to compact the project files into an archive datafile.
    #   $true = Successfully compacted the project files into an archive datafile.
    # -------------------------------
    #>
    hidden static [bool] __CompileProject([string] $archiveFileName, `      # Requested archive datafile
                                            [ref] $filePath, `              # Absolute Path of the Archive datafile
                                            [string] $projectPath)          # Absolute Path of the Temporary Directory Project location
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();

        # Retrieve the current instance of the Project Information object; this contains details
        #  in regards to where the source files exists within the user's system.
        [ProjectInformation] $projectInformation = [ProjectInformation]::GetInstance();


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Show that we are about to compact the project's source files into an archive datafile.
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Compile $($projectInformation.GetProjectName())");
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Compiling $($projectInformation.GetProjectName()). . .");


        # Show that we are using the Archive ZIP Module
        [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::InProgress, "Compacting using the default compression software. . .");

        # Compact the files
        if (!$defaultCompress.CreateArchive($archiveFileName, `
                                            $userPreferences.GetProjectBuildsPath(), `
                                            $projectPath, `
                                            $filePath))
        {
            # Reached an error while trying to compact the files.

            # Alert the user that an error had been reached.
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


            # An error had been reached while compacting the project's files.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "An error occurred while compiling $($projectInformation.GetProjectName())!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Please review the logs for more information!");
            [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Unable to compile this project at this time.");



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("Failed to compile $($projectInformation.GetProjectName())!`r`n" + `
                                            "Please inspect the logs for what could had caused the problem.");

            # Generate the initial message
            $logMessage = "An error had been reached while compiling $($projectInformation.GetProjectName())!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Compression Tool: Archive Module [Default]`r`n" + `
                                "`tArchive File Name Requested: $($archiveFileName)`r`n" + `
                                "`tOutput Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                                "`tProject Path: $($projectPath)`r`n" + `
                                "`tEntire Path (Optional): $($filePath.Value)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *


            # Because the compiling process had reached an error, return a failure signal back.
            return $false;
        } # If : Compiling Project Reached an Error



        # If we made it this far, that means that the operation was successful!
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully compiled $($projectInformation.GetProjectName())!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully compiled the $($projectInformation.GetProjectName()) project!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Archive File Name Requested: $($archiveFileName)`r`n" + `
                            "`tOutput Path: $($userPreferences.GetProjectBuildsPath())`r`n" + `
                            "`tProject Path: $($projectPath)" + `
                            "`tEntire Path: $($filePath.Value)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful
        return $true;
    } # __CompileProject()





   <# Create Project Temporary Directory
    # -------------------------------
    # Documentation:
    #  This function will try to assure that a new temporary directory
    #   had been created successfully.  This temporary directory is
    #   critical to the compiling process, as this will allow us the
    #   ability to modify the project files such that it will have no
    #   effect to original project files.
    #  Thus, if we need to alter the state of the project files,
    #   manipulate, configure, or remove certain files, we may do so
    #   while NOT changing the original source.
    # -------------------------------
    # Input:
    #  [string] (REFERENCE) Temporary Directory Path
    #   Once populated, this will hold the temporary directory's absolute location.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to create the temporary directory.
    #   $true  = Successfully created the temporary directory.
    # -------------------------------
    #>
    hidden static [bool] __CreateProjectTemporaryDirectory([ref] $directoryPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the Project Information object; this contains details
        #  in regards to where the source files exists within the user's system.
        [ProjectInformation] $projectInformation = [ProjectInformation]::GetInstance();

        # This variable will provide the key term of the temporary directory to be created.
        [string] $directoryKeyTerm = $null;

        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # Show that we trying to create a temporary directory
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Creating a new temporary directory. . .");


        # Generate the Key Term of the Temporary Directory
        $directoryKeyTerm = "Compile_" + $projectInformation.GetFileName();


        # Create the temporary directory
        if (![CommonIO]::MakeTempDirectory($directoryKeyTerm, $directoryPath))
        {
            # Failed to create the temporary directory!

            # Alert the user that an error had been reached
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


            # Show the user that an error had been reached while creating the temporary directory.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to create the temporary directory!");


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I was unable to create the temporary directory.`r`n" + `
                                            "Please make sure that you have the sufficient privileges to create a temporary directory.");

            # Generate the initial message
            $logMessage = "Unable to create a temporary directory for the $($projectInformation.GetProjectName()) source files!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please assure that you have sufficient privileges to create a temporary directory.`r`n" + `
                                "`tTemporary Directory Root Location: $($env:TEMP)`r`n" + `
                                "`tTemporary Directory Key Term: $($directoryKeyTerm)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level


            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *



            # Operation had failed
            return $false;
        } # if : Failed to Create Temp. Directory



        # Successfully created the temporary directory
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully created a temporary directory!");
        [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Temporary Directory Path is: " + $directoryPath.Value);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully created a temporary directory for the $($projectInformation.GetProjectName()) source files!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Temporary Directory Root Location: $($env:TEMP)`r`n" + `
                            "`tTemporary Directory Key Term: $($directoryKeyTerm)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful!
        return $true;
    } # __CreateProjectTemporaryDirectory()





   <# Duplicate Source Files to Temporary Directory.
    # -------------------------------
    # Documentation:
    #  This function will duplicate the project's source files from the user's
    #   specified location to the temporary directory.
    #  We will need to perform this operation such that we may configure the
    #   source files as needed - for whatever reason.
    # -------------------------------
    # Input:
    #  [string] Temporary Directory Path
    #   This provides the destination path that will have the source files.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to duplicate the project's contents.
    #   $true  = Successfully duplicated the project's contents.
    # -------------------------------
    #>
    static hidden [bool] __DuplicateSourceToTemporaryDirectory([string] $projectTemporaryPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();


        # Retrieve the current instance of the Project Information object; this contains details
        #  in regards to where the source files exists within the user's system.
        [ProjectInformation] $projectInformation = [ProjectInformation]::GetInstance();


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------


        # Show that we are about to duplicate the project's source files.
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Duplicating $($projectInformation.GetProjectName()) source files. . .");
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "Source: $($projectInformation.GetProjectPath())");
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "Destination $($projectTemporaryPath)");


        # Try to duplicate the files
        if (![CommonIO]::CopyDirectory("$($projectInformation.GetProjectPath())\*",    # Source Directory
                                        $projectTemporaryPath))                     # Destination Directory
        {
            # Alert the user that an error had been reached
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


            # Show the user that an error had been reached while creating the temporary directory.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Failed to duplicate the project's resources!");


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I was not able to duplicate $($projectInformation.GetProjectName()) assets to the temporary directory!");

            # Generate the initial message
            $logMessage = "Unable to duplicate $($projectInformation.GetProjectName()) assets to the temporary directory.";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Directories:`r`n" + `
                                "`tTemporary Directory Root Location: $($env:TEMP)`r`n" + `
                                "`tTemporary Directory Location: $($projectTemporaryPath)`r`n" + `
                                "`t$($projectInformation.GetProjectName()) Source Location: $($projectInformation.GetProjectPath())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Error);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Error);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *

            # Operation had failed
            return $false;
        } # if : Failed to duplicate resources


        # Successfully created the temporary directory
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully duplicated $($projectInformation.GetProjectName()) assets!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully duplicated $($projectInformation.GetProjectName()) assets!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Directories:`r`n" + `
                            "`tTemporary Directory Root Location: $($env:TEMP)`r`n" + `
                            "`tTemporary Directory Location: $($projectTemporaryPath)`r`n" + `
                            "`t$($projectInformation.GetProjectName()) Source Location: $($projectInformation.GetProjectPath())");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful!
        return $true;
    } # __DuplicateSourceToTemporaryDirectory()





   <# Delete Project Temporary Directory
    # -------------------------------
    # Documentation:
    #  This function will delete the temporary directory that was previously
    #   created in order to compile the project with special instructions,
    #   in which does not effect the original project source files.
    # -------------------------------
    # Input:
    #  [string] Temporary Directory Path
    #   This provides the temporary directory path that is to be expunged.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to delete the temporary directory.
    #   $true  = Successfully deleted the temporary directory.
    # -------------------------------
    #>
    hidden static [bool] __DeleteProjectTemporaryDirectory([string] $projectTemporaryPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Show that we trying to delete the temporary directory
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Deleting temporary directory. . .");


        # Try to delete the temporary directory and all of the data within.
        if (![CommonIO]::DeleteDirectory($projectTemporaryPath))
        {
            # Failed to delete the temporary directory


            # Alert the user that an error had been reached
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Warning);


            # Show the user than an error had been reached while deleting the temporary directory.
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Warning, "Unable to delete the temporary directory!");


            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate a message to display to the user.
            [string] $displayErrorMessage = ("I was unable to delete the project's temporary directory.`r`n" + `
                                            "Make sure that you have sufficient privileges to delete the temporary directory.");

            # Generate the initial message
            $logMessage = "Unable to delete the temporary directory!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Please assure that you have sufficient privileges to delete a temporary directory.`r`n" + `
                                "If the directory cannot be discarded, then the Operating System may do so automatically in a later time.`r`n" + `
                                "`tTemporary Directory Root Location: $($env:TEMP)`r`n" + `
                                "`tTemporary Directory Location: $($projectTemporaryPath)");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                        $logAdditionalMSG, `        # Additional information
                                        [LogMessageLevel]::Warning);  # Message level

            # Display a message to the user that something went horribly wrong
            #  and log that same message for referencing purpose.
            [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                        [LogMessageLevel]::Warning);  # Message level

            # Alert the user through a message box as well that an issue had occurred;
            #   the message will be brief as the full details remain within the terminal.
            [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Exclamation) | Out-Null;

            # * * * * * * * * * * * * * * * * * * *



            # Operation had failed
            return $false;
        } # if: Failed to Delete Directory



        # Successfully created the temporary directory
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully deleted the temporary directory!");
        [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Child, "Temporary Directory Path that was Deleted: " + $projectTemporaryPath);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully deleted the temporary directory!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Temporary Directory Root Location: $($env:TEMP)`r`n" + `
                            "`tTemporary Directory Location: $($projectTemporaryPath)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                    $logAdditionalMSG, `        # Additional information
                                    [LogMessageLevel]::Verbose);  # Message level

        # * * * * * * * * * * * * * * * * * * *



        # Operation was successful!
        return $true;
    } # __DeleteProjectTemporaryDirectory()





   <# Expunge Extraneous Resources
    # -------------------------------
    # Documentation:
    #  This function provides the ability to remove files and directories
    #   that are not meant to be part of the compiled build.  Thus, special
    #   files and directories that meant for git or for other tools, will
    #   be removed by this function.
    # -------------------------------
    # Input:
    #  [string] Temporary Directory Path
    #   This provides the temporary directory that contains the files
    #    that are to be removed.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to expunge the superfluous files
    #   $true  = Successfully expunged the superfluous files.
    # -------------------------------
    #>
    hidden static [bool] __ExpungeExtraneousResources([string] $temporaryDirectoryPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Superfluous assets to be discarded
        #  This will provide a list of directories that are to be expunged.
        [System.Collections.ArrayList] $foldersToDelete = [System.Collections.ArrayList]@();

        #  This will provide a list of files that are to be expunged.
        [System.Collections.ArrayList] $filesToDelete = [System.Collections.ArrayList]@();


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Populate the arrays with what we want to delete
        # - - - - - - - - - - - - - - - - - - - - - - - - -
        # = = = = = = = = = = = = = = = = = = = = = = = = =
        # Directories to Remove
        # - - - -
        $foldersToDelete.Add("$($temporaryDirectoryPath)\.git");            # SCM Git
        $foldersToDelete.Add("$($temporaryDirectoryPath)\TEMP");            # Temporary Directory
        $foldersToDelete.Add("$($temporaryDirectoryPath)\Temporary");       # Temporary Directory
        $foldersToDelete.Add("$($temporaryDirectoryPath)\Tools");           # Tools Directory
        $foldersToDelete.Add("$($temporaryDirectoryPath)\Github Services"); # Github Services; usually wiki
        $foldersToDelete.Add("$($temporaryDirectoryPath)\Github");          # Github Resources

        # Files to Remove
        # - - - -
        $filesToDelete.Add(".gitattributes");                       # Repository File Attributes and Behavior
        $filesToDelete.Add(".gitignore");                           # Ignore specific files within Local Repository
        $filesToDelete.Add("*.md");                                 # GitHub's Services; GitHub specific files
        $filesToDelete.Add("Thumb.dbs");                            # WINDOWS: Picture thumbnail database
        $filesToDelete.Add("desktop.ini");                          # WINDOWS: Explorer Properties for WD




        # Show that we are about to expunge superfluous files and directories.
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Deleting unnecessary assets. . .");



        # Show that we are trying to delete unnecessary directories
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Deleting unnecessary directories. . .");


        # Try to delete directories that we do not want.
        foreach($i in $foldersToDelete)
        {
            # Delete the desired directory
            if (![CommonIO]::DeleteDirectory($i))
            {
                # Unable to delete the desired directory

                # Alert the user that an error had been reached.
                [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


                # Show that the directory could not be deleted.
                [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to delete folder $($i)!");
                [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "The folder could not be removed.");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("Unable to delete a redundant folder: ($($i))`r`n" + `
                                                "Please inspect the logs for what could had caused the problem.");

                # Generate the initial message
                $logMessage = "An error had been reached while removing superfluous directories!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Unable to delete directory: $($i)`r`n" + `
                                    "Additional directories to be removed:`r`n" + `
                                    "`t - $($foldersToDelete -join "`r`n`t - ")");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                            $logAdditionalMSG, `        # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # Alert the user through a message box as well that an issue had occurred;
                #   the message will be brief as the full details remain within the terminal.
                [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

                # * * * * * * * * * * * * * * * * * * *



                # Because we cannot delete the requested directory, we have to abort the operation.
                return $false;
            } # If : Failed to delete directory
        } # Foreach: Delete Directories



        # Show that we are trying to delete unnecessary files
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Deleting unnecessary files. . .");


        # Delete the desired file(s) - using the Recursive flag
        if (![CommonIO]::DeleteFile($temporaryDirectoryPath, $filesToDelete.ToArray(), $true))
        {
                # Unable to delete the desired files

                # Alert the user that an error had been reached.
                [NotificationAudible]::Notify([NotificationAudibleEventType]::Error);


                # Show that the files could not be deleted.
                [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::Failure, "Unable to delete the files!");
                [Builder]::__DisplayBulletListMessage(3, [FormattedListBuilder]::NoSymbol, "Files to be removed: `r`n`t - $($filesToDelete -join "`r`n`t - ")");



                # * * * * * * * * * * * * * * * * * * *
                # Debugging
                # --------------

                # Generate a message to display to the user.
                [string] $displayErrorMessage = ("Unable to delete redundant files that were not needed for the compiled build.`r`n" + `
                                                "Please inspect the logs for what could had caused the problem.");

                # Generate the initial message
                $logMessage = "An error had been reached while removing superfluous files!";

                # Generate any additional information that might be useful
                $logAdditionalMSG = ("Files to be removed:`r`n" + `
                                    "`t - $($filesToDelete -join "`r`n`t - ")");

                # Pass the information to the logging system
                [Logging]::LogProgramActivity($logMessage, `            # Initial message
                                            $logAdditionalMSG, `        # Additional information
                                            [LogMessageLevel]::Error);  # Message level

                # Display a message to the user that something went horribly wrong
                #  and log that same message for referencing purpose.
                [Logging]::DisplayMessage($displayErrorMessage, `       # Message to display
                                            [LogMessageLevel]::Error);  # Message level

                # Alert the user through a message box as well that an issue had occurred;
                #   the message will be brief as the full details remain within the terminal.
                [CommonGUI]::MessageBox($logMessage, [System.Windows.MessageBoxImage]::Hand) | Out-Null;

                # * * * * * * * * * * * * * * * * * * *



                # Because we cannot delete the requested file, we have to abort the operation.
                return $false;
        } # If : Failed to delete file(s) - with Recursive Flag



        # Successfully deleted unnecessary resources
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully deleted unnecessary assets!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully removed unnecessary files and directories!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Files Removed:`r`n" + `
                            "`t`t - $($foldersToDelete -join "`r`n`t`t - ")`r`n" + `
                            "`tDirectories Removed: `r`n" + `
                            "`t`t - $($filesToDelete -join "`r`n`t`t - ")");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # The operation was successful
        return $true;
    } # __ExpungeExtraneousResources()





   <# Test Compiled Build
    # -------------------------------
    # Documentation:
    #  This function will perform a test against the newly compiled
    #   archive datafile, such that we may assure that the build is
    #   healthy and consumable upon request.  If the build is damaged
    #   during the compiling phase, then this function will report
    #   that the build is not healthy - in which the user will need to
    #   take specific action regarding that build if necessary.
    # -------------------------------
    # Input:
    #  [string] Compiled Build Full Path
    #   The requested archive datafile that will be tested; absolute
    #    full path is required.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = The archive datafile is damaged or corrupted.
    #   $true  = The archive datafile is healthy
    #               OR
    #            User did not want to test the archive datafile.
    # -------------------------------
    #>
    hidden static [bool] __TestCompiledBuild([string] $compiledBuildFullPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object;
        #  this contains the user's generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();


        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();


        # This will store the exit condition provided by the test function.
        [bool] $result = $false;


        # This is equivalent to the result [boolean], but this will be displayed onto the terminal.
        #  We will populated this value with a default value with 'Failed'.  We will update this value
        #  if the test indicated that the build is healthy.
        [string] $resultNiceValue = "Damaged; not healthy";


        # With this variable, we can adjust the symbol that is provided when providing
        #  the bullet message to the user.  By default, we will focus on the error.
        [FormattedListBuilder] $resultSymbol = [FormattedListBuilder]::Failure;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------




        # Did the user wanted us to check the health of the archive datafile?
        if (!$defaultCompress.GetVerifyBuild())
        {
            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to check the health of the archive data file!";

            # Generate any additional information that might be useful
            $logAdditionalMSG = ("Verify Setting: $([string]$defaultCompress.GetVerifyBuild())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Even though we did not perform the check, we will still return a successful signal to keep the process running.
            return $true;
        } # if : Do Not Check Build Health




        # Show that we are about to check the compiled build's health
        #  and integrity of its data structure.
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Checking the archive file's health");
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "File to inspect: $($compiledBuildFullPath)");


        # Let the user know that the test is starting
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Checking build. . .");



        # Perform the test.
        $result = $defaultCompress.VerifyArchive($compiledBuildFullPath);


        # Revise the Nice Result such that we indicate that the build is healthy
        if ($result)
        {
            # We will show that the build is healthy
            $resultNiceValue = "Healthy";

            # Revise the symbol such that we do not push an error symbol
            $resultSymbol = [FormattedListBuilder]::Child;
        } # if : Archive is Healthy

        # If the build is corrupted, we will notify the user by audible notification.
        else
        {
            # Build is not healthy

            # Alert the user that the build is not healthy.
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Warning);
        } # else : Build is Not Healthy



        # Show that the operation was successful and provide the condition of the build
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Successful, "Successfully checked compiled build's health!");
        [Builder]::__DisplayBulletListMessage(2, $resultSymbol, "The compiled build is: " + $resultNiceValue + "!");



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully checked the archive file; health of the build is [$($resultNiceValue)]!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Archive file checked: $($compiledBuildFullPath)`r`n" + `
                            "`tNice Result Provided: $($resultNiceValue)`r`n" + `
                            "`tResult Given: $($result)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # Return the result back to the calling function
        return $result;
    } # __TestCompiledBuild()





   <# Generate Report: Archive Data File
    # -------------------------------
    # Documentation:
    #  This function will try to create a report regarding the newly
    #   compiled archive datafile.  This will provide a thorough
    #   outlook regarding information about the file itself as well
    #   as the contents within the archive datafile.
    # -------------------------------
    # Input:
    #  [string] Compiled Build Full Path
    #   The requested archive datafile that will be tested; absolute
    #    full path is required.
    # -------------------------------
    # Output:
    #  [bool] Exit code
    #   $false = Failed to create the desired report
    #   $true  = Successfully created the requested report
    # -------------------------------
    #>
    hidden static [bool] __GenerateReportArchiveDataFile([string] $compiledBuildFullPath)
    {
        # Declarations and Initializations
        # ----------------------------------------
        # Retrieve the current instance of the User Preferences object; this contains the user's
        #  generalized settings.
        [UserPreferences] $userPreferences = [UserPreferences]::GetInstance();

        # Retrieve the current instance of the user's Default Compressing object; this contains
        #  the user's preferences as to how the Archive ZIP module will be utilized within this
        #  application.
        [DefaultCompress] $defaultCompress = [DefaultCompress]::GetInstance();

        # This will store the exit condition provided by the test function.
        [bool] $result = $false;

        # This is equivalent to the result [boolean] variable, but this will be displayed onto the
        #  terminal.  We will populate this value with a default value signifying that it had failed.
        #  However, we will update this value if the resulting operation was successful.
        [string] $resultNiceValue = "Failed to create the report on the archive file!";

        # With this variable, we can adjust the symbol that is provided when issuing the bullet
        #  message to the user.  By default, we will use an error - but change it later if the
        #  operation was successful.
        [FormattedListBuilder] $resultSymbol = [FormattedListBuilder]::Failure;

        # When populated, this variables will hold the absolute path of the generated report text file.
        [string] $fullPathReportTextFile = $null;


        # Debugging Variables
        [string] $logMessage = $NULL;           # Main message regarding the logged event.
        [string] $logAdditionalMSG = $NULL;     # Additional information about the event.
        # ----------------------------------------



        # Determine if the user wanted a report generated and with what compression tool.
        if (!$defaultCompress.GetGenerateReport())
        {
            # User does not want a report generated.



            # * * * * * * * * * * * * * * * * * * *
            # Debugging
            # --------------

            # Generate the initial message
            $logMessage = "The user does not wish to generate a report on the archive data file!";

            # Generate any additional information that might be useful
             $logAdditionalMSG = ("Generate Report Setting: $([string]$defaultCompress.GetGenerateReport())");

            # Pass the information to the logging system
            [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                        $logAdditionalMSG, `            # Additional information
                                        [LogMessageLevel]::Verbose);    # Message level

            # * * * * * * * * * * * * * * * * * * *



            # Even though we did not perform the check, we will still return a successful signal to keep the process running.
            return $true;
        } # if : Generate Report using Default Compression Tool




        # Show that we are about to generate a report of the archive data file
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "Generating report of the archive file");
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Child, "Report will be based on this archive file: " + $compiledBuildFullPath);


        # Let the user know that the report is being created
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::InProgress, "Generating report. . .");


        # Generate the report
        $result = $defaultCompress.CreateNewReport($compiledBuildFullPath, `
                                                    [ref] $fullPathReportTextFile);



        # Provide the user the locations as to where the report files are placed within the their system.
        #  Also revise the Nice Result such that we indicate that the report had been created successfully.
        if ($result)
        {
            # Because the reports were successfully generated, show where the files are located within their
            #  system.

            # Report File - Text Report
            # = - - - - - - - - - - - =
            [Builder]::__DisplayBulletListMessage(2, [FormattedListBuilder]::NoSymbol, $fullPathReportTextFile);


            # Access the desired directory and select the file.
            [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($fullPathReportTextFile), `
                                        [System.IO.Path]::GetFileName($fullPathReportTextFile));


            # Revise the status messages

            # We will show that the report was successfully created
            $resultNiceValue = "Successfully created the report!";

            # Revise the symbol such that we do not push an error symbol
            $resultSymbol = [FormattedListBuilder]::Child;
        } # if : Report Created Successfully

        # If the report could not be successfully generated.
        else
        {
            # Unable to generate report

            # Alert the user that the report could not be made.
            [NotificationAudible]::Notify([NotificationAudibleEventType]::Warning);
        } # else : Failed to Generate Report



        # Show that the operation had been completed; provide its results
        [Builder]::__DisplayBulletListMessage(1, $resultSymbol, $resultNiceValue);



        # * * * * * * * * * * * * * * * * * * *
        # Debugging
        # --------------

        # Generate the initial message
        $logMessage = "Successfully attempted to create a report based on the archive file!";

        # Generate any additional information that might be useful
        $logAdditionalMSG = ("Report based on the following archive file: $($compiledBuildFullPath)`r`n" + `
                            "`tNice Result Provided: $($resultNiceValue)`r`n" + `
                            "`tResult Given: $($result)");

        # Pass the information to the logging system
        [Logging]::LogProgramActivity($logMessage, `                # Initial message
                                    $logAdditionalMSG, `            # Additional information
                                    [LogMessageLevel]::Verbose);    # Message level

        # * * * * * * * * * * * * * * * * * * *


        # Return the result back to the calling function
        return $result;
    } # __GenerateReportArchiveDataFile()





   <# Show Project Location
    # -------------------------------
    # Documentation:
    #  This function will merely show where the project is located within the host's filesystem.
    # -------------------------------
    # Input:
    #  [string] Project Path
    #   The absolute path of the compiled project within the filesystem.
    # -------------------------------
    #>
    hidden static [void] __ShowProjectLocation([string] $projectPath)
    {
        # Let the user know that we are about to show them the path to their newly generated compiled build.
        [Builder]::__DisplayBulletListMessage(0, [FormattedListBuilder]::Parent, "You will find `"$([System.IO.Path]::GetFileName($projectPath))`" in this location:");

        # Show the path
        [Builder]::__DisplayBulletListMessage(1, [FormattedListBuilder]::Child, $projectPath);

        # Reveal the project to the user using their preferred GUI Shell
        [CommonIO]::AccessDirectory([System.IO.Path]::GetDirectoryName($projectPath), `
                                    [System.IO.Path]::GetFileName($projectPath));
    } # __ShowProjectLocation()





   <# Display Bullet List Message
    # -------------------------------
    # Documentation:
    #  This function will act as a gateway into accessing the Formatted List.
    # -------------------------------
    # Input:
    #  [unsigned int] Message Position
    #   The position of the message that is to be displayed.  The position entails
    #       as to how many indentions are required before displaying the message.
    #  [FormattedListBuilder] Message Type
    #   The type of message that is to be presented to the user.  This usually could
    #       be a simple bullet list or provides a unique character for the message based
    #       on certain events.
    #  [string] Message String
    #   The message that will be displayed to the user.
    # -------------------------------
    #>
    hidden static [void] __DisplayBulletListMessage([uint] $messagePosition, `              # How many indentions before message
                                                    [FormattedListBuilder] $messageType, `  # Type of list or message
                                                    [string] $messageString)                # Initial message to display
    {
        # Declarations and Initializations
        # ----------------------------------------
        # This will hold the desired bullet point symbol or any special symbol
        #  that matches with the type of the message.
        [char] $bulletCharacter = $null;

        # Symbols that will be used when providing a list.
        [char] $symbolParent        = '>';     # Main Operation
        [char] $symbolChild         = '-';     # Sub-Main Operation
        [char] $symbolInProgress    = '-';     # Task presently running
        [char] $symbolSuccessful    = '-';     # Operation finished successfully
        [char] $symbolWarning       = '!';     # Reached a warning case
        [char] $symbolFailure       = '!';     # Operation reached an error
        [char] $symbolNoSymbol      = ' ';     # Generic message with on symbol.
        # ----------------------------------------



        # Determine which symbol to use
        switch ($messageType)
        {
            # Parent
            ([FormattedListBuilder]::Parent)
            {
                # Use the Parent Symbol
                $bulletCharacter = $symbolParent;

                # Finished
                break;
            } # Parent


            # Child
            ([FormattedListBuilder]::Child)
            {
                # Use the Child Symbol
                $bulletCharacter = $symbolChild;

                # Finished
                break;
            } # Child


            # In-Progress
            ([FormattedListBuilder]::InProgress)
            {
                # Use the In-Progress Symbol
                $bulletCharacter = $symbolInProgress;

                # Finished
                break;
            } # In-Progress


            # Successful
            ([FormattedListBuilder]::Successful)
            {
                # Use the Successful Symbol
                $bulletCharacter = $symbolSuccessful;

                # Finished
                break;
            } # Successful


            # Warning
            ([FormattedListBuilder]::Warning)
            {
                # Use the Warning Symbol
                $bulletCharacter = $symbolWarning;

                # Finished
                break;
            } # Warning


            # Failure
            ([FormattedListBuilder]::Failure)
            {
                # Use the Failure Symbol
                $bulletCharacter = $symbolFailure;

                # Finished
                break;
            } # Failure


            # No Symbol
            ([FormattedListBuilder]::NoSymbol)
            {
                # Provide an empty space
                $bulletCharacter = $symbolNoSymbol;

                # Finished
                break;
            } # No Symbol


            # No Symbol
            default
            {
                # Do not use a symbol
                break;
            } # No Symbol
        } # Switch : Determine Symbol to Use



        # Provide the message
        [CommonCUI]::DrawFormattedList($messagePosition, `      # How many spaces to indent the message
                                        $bulletCharacter, `     # What symbol to use (optional)
                                        $messageString);        # Message to display
    } # __DisplayBulletListMessage()
} # Builder




<# Builder Formatted List [ENUM]
 # -------------------------------
 # This will allow the ability to organize the type of messages that will be
 #  used within the Builder.
 # -------------------------------
 #>
enum FormattedListBuilder
{
    Parent         = 0; # Main Operation
    Child          = 1; # Sub-Operation
    InProgress     = 2; # Current Action
    Successful     = 3; # Operation was successful
    Warning        = 4; # A Warning had been raised
    Failure        = 5; # Operation had reached a failure
    NoSymbol       = 6; # No Symbol provided
} # FormattedListBuilder
