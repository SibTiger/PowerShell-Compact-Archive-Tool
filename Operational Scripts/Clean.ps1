<# PowerShell Compact-Archive Tool
 # Copyright (C) 2022
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #>





<#
.SYNOPSIS
    Deletes data that was generated by PowerShell Compact-Archive Tool.

.DESCRIPTION
    This tool will provide a special instruction to the PowerShell Compact-Archive Tool to perform a clean-up operation.
        In doing so, the PowerShell Compact-Archive Tool will perform the clean-up operating within the system.

    Tools that this program utilizes are:
        PowerShell Core 7.1.x Minimum
            This is required in order for the PSCAT software to work properly.
        PowerShell Compact-Archive Tool (version 1.1.0 minimum)
            This specifies which version of PSCAT supports this functionality.
.NOTES
    Author: Nicholas Gautier
    Email: Nicholas.Gautier.Tiger@GMail.com
    Project Website: https://github.com/SibTiger/PowerShell-Compact-Archive-Tool

.INPUTS
    Nothing is to be given or to be provided from a command or pipe.

.OUTPUTS
    Nothing is to be returned or to be sent to the pipe.

.EXAMPLE
    .\cleanup.ps1

.LINK
    https://github.com/SibTiger/PowerShell-Compact-Archive-Tool
#>





# Initialization
# -------------------------------
# Documentation:
#   This function will initialize all of the required variables that we will need within this application.
#   This is mainly to help when needing to maintain this application over future generations of PSCAT.
# -------------------------------
function Initialization()
{
    # PSCAT Filename
    Set-Variable -Name "__PSCAT_FILENAME__" -Value "PSCAT.ps1" `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "PowerShell Compact-Archive Tool's filename";

    # PSCAT Absolute Path
    #  NOTE: This script should reside with the PSCAT application.
    Set-Variable -Name "__PSCAT_FULL_PATH__" -Value $PSScriptRoot `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "Base path in which the PSCAT application will reside";

    # PSCAT Complete Path
    Set-Variable -Name "__PSCAT_COMPLETE_PATH__" -Value "$($__PSCAT_FULL_PATH__)\$($__PSCAT_FILENAME__)" `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "PowerShell Compact-Archive Tool's absolute path - including filename.";

    # PSCAT Operation Code
    Set-Variable -Name "__PSCAT_OPERATION_CODE__" -Value 1 `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "Signifies the 'Clean' Operation mode in PowerShell Compact-Archive Tool.";

    # PowerShell Core Executable Name
    Set-Variable -Name "__POWERSHELL_EXECUTABLE__" -Value "pwsh.exe" `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "PowerShell Core's filename";

    # PowerShell Core Path
    Set-Variable -Name "__POWERSHELL_PATH__" -Value "$($env:ProgramFiles)\PowerShell\" `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "Common base path for PowerShell Core";

    # PowerShell Core Complete Path
    #  Populated later within the application.
    Set-Variable -Name "__POWERSHELL_COMPLETE_PATH__" -Value $null `
        -Scope Global -Force -Option None -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "PowerShell Core's absolute path [Must be generated before use]";

    # Exit Codes : Cannot Find PSCAT
    Set-Variable -Name "__EXITCODE_CANNOT_FIND_PSCAT__" -Value 500 `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "Exit Code signifying that the PowerShell Compact-Archive Tool could not be found.";

    # Exit Codes : Failed Launch PSCAT
    Set-Variable -Name "__EXITCODE_FAILED_TO_LAUNCH_PSCAT__" -Value 501 `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "Exit Code Signifying that the PowerShell Compact-Archive Tool could not be started.";

    # Exit Codes : Cannot Find PowerShell Core
    Set-Variable -Name "__EXITCODE_CANNOT_FIND_POSHCORE__" -Value 502 `
        -Scope Global -Force -Option Constant -ErrorAction SilentlyContinue `
        -Visibility Private `
        -Description "Exit Code signifying that the PowerShell Core could not be found.";
} # Initialization()





Class Clean
{
    # Launch the PowerShell Compact-Archive Tool
    # -------------------------------
    # Documentation:
    #   This function will execute the PowerShell Compact-Archive Tool and set the Program Mode to 'Clean'.
    # -------------------------------
    # Output:
    #   [Int] Exit Code
    #       This is the exit code provided by the PowerShell Compact-Archive Tool program.
    # -------------------------------
    hidden static [Int32] LaunchPSCAT()
    {
        # Declarations and Initializations
        # --------------------------------------
        # We are going to use 'Splatting' to make this easier to construct the Start-Process arguments.
        [System.Collections.Hashtable] $hashArguments = [System.Collections.Hashtable]::New();

        # We are going to use this variable to capture the Exit Code from PSCAT.
        [System.Diagnostics.Process] $processInformation = [System.Diagnostics.Process]::New();
        # --------------------------------------



        # Construct the arguments
        $hashArguments = @{
            FilePath            = "$($Global:__POWERSHELL_COMPLETE_PATH__)";
            WorkingDirectory    = "$($Global:__PSCAT_FULL_PATH__)";
            ArgumentList        = "-File "".\$($Global:__PSCAT_FILENAME__)"" -ProgramMode $Global:__PSCAT_OPERATION_CODE__";
            Wait                = $true;
            NoNewWindow         = $true;
            PassThru            = $true;
            } # Start-Process Arguments



        # Launch the PowerShell Compact-Archive Tool program
        $processInformation = Start-Process @hashArguments;


        # Return PSCAT's Exit Code
        return $processInformation.ExitCode;
    } # LaunchPSCAT()






    # Test File Path
    # -------------------------------
    # Documentation:
    #   This function will inspect the complete path in which the file supposedly resides.
    # -------------------------------
    # Output:
    #   [Bool] Exist Result
    #       $True   - File exists within the given path.
    #       $False  - File could not be found with the provided path.
    # -------------------------------
    hidden static [bool] TestFilePath([string] $pathToExamine)
    {
        # Check to see if we can find the file
        if (Test-Path -LiteralPath "$($pathToExamine)" -PathType Leaf)
        {
            # Found the target file
            return $true;
        } # if : Found Target


        # Unable to find the target file
        return $false;
    } # TestFilePath()






    # Find PowerShell Core
    # -------------------------------
    # Documentation:
    #   This function will examine the common ways in which we can be able to locate the PowerShell Core
    #   application within the host system's environment.
    #
    #   This function will try to find the PowerShell Core by checking the following:
    #       1) Checking the system's environment variable, $PATH.
    #       2) Checking the default install location.
    # -------------------------------
    hidden static [bool] FindPowerShellCore()
    {
        # Declarations and Initializations
        # --------------------------------------------
        # We will use this to store as many directories associated with the PowerShell Core's install location.
        [System.Object[]] $qualifiedDirectory = [System.Object]::New();
        # --------------------------------------------



        # Lets first take the easy approach, $PATH
        if ($null -ne $(Get-Command -Name "$($GLOBAL:__POWERSHELL_EXECUTABLE__)" -CommandType Application))
        {
            # Successfully found it in $PATH


            # Update the global variable's value.
            $Global:__POWERSHELL_COMPLETE_PATH__ = "$($GLOBAL:__POWERSHELL_EXECUTABLE__)";


            # Successfully found POSH from the System's environment variable
            return $true;
        } # if : Scan $PATH


        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


        # Try to find it within the default installation path.
        $qualifiedDirectory = Get-ChildItem -Path "$Global:__POWERSHELL_PATH__" | `     # Obtain all possible sub-directories within the location
                                Where-Object {$_ -match '([7-9]$|[0-9].$)'} | `         # Filter all names that do not start with 7 to 9
                                Sort-Object -Property {[UInt16]$_.Name};                # Output all results that fit the criteria.


        # Check to make sure that we where able to capture one or more hits; otherwise - we may not proceed.
        if ($qualifiedDirectory.Count -eq 0)
        {
            # Because we could not find any installed versions, we can not proceed.
            return $false;
        } # if : No PowerShell Core Installation


        # Try to use the latest version of the PowerShell Core application
        for ([uint16] $i = $qualifiedDirectory.Count; $i -ge 0; $i--)
        {
            # Construct the complete path
            $Global:__POWERSHELL_COMPLETE_PATH__ = ("$($Global:__POWERSHELL_PATH__)" + `            # Base path
                                                    "$($qualifiedDirectory[$i - 1].Name)" + `       # Qualified Directory
                                                    "\$($Global:__POWERSHELL_EXECUTABLE__)");       # Executable File Name


            # Check the path
            if (Test-Path -LiteralPath $Global:__POWERSHELL_COMPLETE_PATH__ `
                        -PathType Leaf)
            {
                # Successfully found PowerShell Core
                return $true;
            } # if : Found PowerShell Core at Path
        } # for : Scan for PowerShell Core Executable


        # Failed to find the PowerShell Core executable
        return $false;
    } # FindPowerShellCore()






    # Display Error Message
    # -------------------------------
    # Documentation:
    #   This function will provide centralized way into creating an error message that will be
    #   displayed to the user's terminal buffer.
    #   We will only provide a static error message, such that the format does not change.
    # -------------------------------
    hidden static [void] DisplayErrorMessage([string] $errorMessage)
    {
        # Declarations and Initializations
        # --------------------------------------------
        # Create the message package that we will need to show the user that we were unable to find the PSCAT tool.
        [System.Management.Automation.HostInformationMessage] $messagePackage = `
            [System.Management.Automation.HostInformationMessage]::New();
        # --------------------------------------------



        # Generate the message package such that it grabs the user's attention immediately.
        $messagePackage.BackgroundColor = "Black";
        $messagePackage.ForegroundColor = "Red";
        $messagePackage.Message = ("`r`n`r`n" + `
                                    "`t`t<!> CRITICAL ERROR <!>`r`n" + `
                                    "------------------------------------------------------`r`n" + `
                                    "$($errorMessage)`r`n" + `
                                    "------------------------------------------------------`r`n");
        $messagePackage.NoNewLine = $false;


        # Display the error message to the user
        Write-Information $messagePackage `
                            -InformationAction Continue;
    } # DisplayErrorMessage()






    # Fetch Enter Key
    # -------------------------------
    # Documentation:
    #   The intention of this function is to allow the ability for the user to view messages that are displayed on the
    #   terminal buffer before the buffer is either flushed or the window is closed.
    # -------------------------------
    hidden static [void] FetchEnterKey()
    {
        # Declarations and Initializations
        # --------------------------------------------
        # Create the Message Package, we will need this to tell the user to press the 'Enter' key.
        [System.Management.Automation.HostInformationMessage] $messagePackage = `
            [System.Management.Automation.HostInformationMessage]::New();
        # --------------------------------------------



        # Now, build the message package
        $messagePackage.BackgroundColor = "Black";
        $messagePackage.ForegroundColor = "White";
        $messagePackage.Message = ("`r`n`r`n"+ `
                                    "Press the Enter key to continue. . .");
        $messagePackage.NoNewLine = $false;


        # Display the message to the user
        Write-Information $messagePackage `
                            -InformationAction Continue;


        # Allow the user read the information before we close the script
        (Get-Host).UI.ReadLine();
    } # FetchEnterKey()






    # Main
    # -------------------------------
    # Documentation:
    #   This function is essentially are main entry point into this program; this is our driver.
    # -------------------------------
    static [Int32] main()
    {
        # Declarations and Initializations
        # --------------------------------------
        # PowerShell Core's complete path
        # We will use this return code to signify the operation.
        [int32] $exitCode = 0;

        # This variable will signify if an error was detected; this will help to reduce code duplication.
        [bool] $caughtError = $false;

        # Error Message
        #  Provides an error message that will be presented to the user.
        [string] $errorMessage = $null;
        # --------------------------------------



        # Make sure that we can find the PowerShell Core software
        if (!$([Clean]::FindPowerShellCore()))
        {
            # Generate the error string regarding the error we just found.
            $errorMessage = ("Failed to detect $($Global:__POWERSHELL_EXECUTABLE__)`r`n" + `
                            "Please make sure that the PowerShell Core application had been installed on your system.`r`n" + `
                            "Expected to find PowerShell Core in the following:`r`n" + `
                            "`t- `$PATH`r`n" + `
                            "`tOR`r`n" + `
                            "`t- $($Global:__POWERSHELL_PATH__)");


            # Adjust the return code to signify that an error had been reached.
            $exitCode = $Global:__EXITCODE_CANNOT_FIND_POSHCORE__;


            # We caught an error
            $caughtError = $true;
        } # if : Unable to find POSHCore


        # Now we will make sure that the PSCAT tool can be found.
        elseif (!$([Clean]::TestFilePath($Global:__PSCAT_COMPLETE_PATH__)))
        {
            # Generate the error string regarding the error we caught.
            $errorMessage = ("Failed to locate $($Global:__PSCAT_FILENAME__)`r`n" + `
                            "Expected Path was:`r`n" + `
                            "`t$($Global:__PSCAT_COMPLETE_PATH__)");


            # Adjust the return code to signify that an error had been reached.
            $exitCode = $Global:__EXITCODE_CANNOT_FIND_PSCAT__;


            # We caught an error
            $caughtError = $true;
        } # if : Unable to find PSCAT


        # We were able to find the PSCAT application, try to call it.
        else
        {
            # Execute PSCAT
            $exitCode = [Clean]::LaunchPSCAT();
        } # Else : Call the Application



        # Was an error reached during the checks?
        if ($caughtError)
        {
            # We already have the error message provided to us already, all that we have to do is show the message.
            [Clean]::DisplayErrorMessage($errorMessage);

            # Allow the user to read the message.
            [Clean]::FetchEnterKey();
        } # if : Error During Checks



        # Provide the operation exit code
        return $exitCode;
    } # main()
} # Clean





# We will begin by initializing the variables that we will be using within this application.
Initialization;



# Start the program
exit [Clean]::main();